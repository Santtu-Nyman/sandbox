#ifndef SNWU_H
#define SNWU_H

#ifdef __cplusplus
extern "C" {
#endif

#include <windows.h>
#ifdef _M_X64
#include <intrin.h>
#elif _M_IX86
#include <intrin.h>
#endif

void snwuClear(VOID* Memory, SIZE_T Size);
/*
	Description
		Fills a block of memory with zeros.
	Parameters
		"Memory" Pointer to the starting of the block of memory.
		"Size" Size of the block of memory in bytes.
	Return value
		This function has no return value.
*/

void snwuCopy(const VOID* Source, VOID* Destination, SIZE_T Size);
/*
	Description
		Copies a block of memory.
	Parameters
		"Source" Pointer to the starting of the block of memory to be copied.
		"Destination" Pointer to the starting of the block of memory to be copy.
		"Size" Size of blocks of memory in bytes.
	Return value
		This function has no return value.
*/

void snwuMove(VOID* Source, VOID* Destination, SIZE_T Size);
/*
	Description
		Moves a block of memory.
	Parameters
		"Source" Pointer to the starting of the source memory block.
		"Destination" Pointer to the starting of the destination memory block.
		"Size" Size of blocks of memory in bytes.
	Return value
		This function has no return value.
*/

typedef struct snwuMutex
{
	// snwu internal data structure. do not access directly.
	volatile LONG _LatestOwner;
	volatile LONG _CurrentOwner;
	BOOL (WINAPI* _WaitOnAddress)(VOID volatile *Address, PVOID CompareAddress, SIZE_T AddressSize, DWORD dwMilliseconds);
	VOID (WINAPI* _WakeByAddressAll)(PVOID Address);
} snwuMutex;
/*
	Opaque mutex structure.
	Needs to be initialized with snwuInitializeMutex fuction before use.
*/

void snwuInitializeMutex(volatile snwuMutex* Mutex);
/*
	Description
		Initializes snwuMutex structure.
		this structure does not require to be uninitialized, freed, ect.
	Parameters
		"Mutex" Pointer to the starting of the mutex to be initialized.
	Return value
		This function has no return value.
*/

void snwuAcquireMutex(volatile snwuMutex* Mutex);
/*
	Description
		Acquires snwuMutex structure.
		RECURESIVE ACQUISITION CAUSES UNDEFINED BEHAVIOR!
	Parameters
		"Mutex" Pointer to the starting of the mutex to be acquired.
		This mutext is required to initialized and not acquired by calling thread.
	Return value
		This function has no return value.
*/

void snwuReleaseMutex(volatile snwuMutex* Mutex);
/*
	Description
		Releases snwuMutex structure.
		RELEASING MUTEX THAT CALLING THREAD HAS NOT ACQUIRED CAUSES UNDEFINED BEHAVIOR!
	Parameters
		"Mutex" Pointer to the starting of the mutex to be released.
		This mutext is required to initialized and acquired by calling thread.
	Return value
		This function has no return value.
*/

SIZE_T snwuStringSize(const WCHAR* String);
/*
	Description
		Calculates size of string in bytes.
	Parameters
		"String" Pointer to the starting of the string.
	Return value
		This function returns the size of string pointed by "String" parameter including terminating null character in bytes.
*/

BOOL snwuCompareStrings(const WCHAR* String0, const WCHAR* String1);
/*
	Description
		Compares two strings.
	Parameters
		"String0" Pointer to the starting of first string.
		"String1" Pointer to the starting of second string.
	Return value
		This function returns non zero if the strings are equal else zero.
*/

DWORD snwuGetRandomSeed();
/*
	Description
		Conjure up 32 bits of random data.
	Parameters
		This function has no parameters.
	Return value
		This function returns 32 bits of somewhat random non cryptographically secure data.
*/

DWORD snwuPrint(const WCHAR* Text, BOOL NewLine);
/*
	Description
		Prints text to console.
	Parameters
		"Text" Pointer to the starting of the string to be printed to console.
		"NewLine" If this parameter is nonzero new line is appended to the string.
	Return value
		If the function succeeds, the return value is zero and windows error code on failure.
*/

DWORD snwuShowError(DWORD Error);
/*
	Description
		Debug function that outputs error code as text to debug output and console. The function does not fail if output fails.
	Parameters
		"Error" Pointer to the starting of the string to be printed to console.
	Return value
		If the function succeeds, the return value is zero and windows error code on failure.
*/

#define SNWU_RANDOM_NAME_LENGHT 8
// Lenght of random name created by snwuCreateFileWithRandomName function.

DWORD snwuCreateFileWithRandomName(HANDLE* Handle, DWORD Access, DWORD ShareMode, BOOL IsDirectory, BOOL DoNotCreate, WCHAR* Path, const WCHAR* Extension);
/*
	Description
		Creates file or directory with random name.
	Parameters
		"Handle" Pointer to buffer that receive a handle to the file or directory created. If this parameter is zero the created file or directory is not opened and no halse is received.
		"Access" The requested access to the file or directory.
		"ShareMode" The requested sharing mode of the file or directory.
		"IsDirectory" If this parameter is nonzero this fuction creates a directory.
		"DoNotCreate" If this parameter is nonzero this fuction does only writes the generated name to the end of the path.
		"Path" Pointer to buffer that contains path of the directory that the random named file or directory is created.
		the random name is appended to this path.
		Size of the appended name is SNWU_RANDOM_NAME_LENGHT and size of extension pointed by "Extension" parameter.
		"Extension" Pointer to starting of the string appended to random name. This parameter can be zero if nothing is appended.
	Return value
		If the function succeeds, the return value is zero and windows error code on failure.
*/

DWORD snwuMapFile(const WCHAR* FileName, DWORD PageProtection, SIZE_T* Size, LPVOID* Mapping, BOOL Prefetch);
/*
	Description
		Maps a file to memory.
	Parameters
		"FileName" Pointer to the starting of the string that contains the name of the file.
		"PageProtection" Protection of the pages that contain the file data.
		"Size" Pointer to variable that receives the size of the file. If running on 32 bit system trying to map files larger than 4 GiB the function fails.
		"Mapping" Pointer to variable that receives pointer to the mapping.
		"Prefetch" If this parameter is nonzero the mapping is prefetched.
	Return value
		If the function succeeds, the return value is zero and windows error code on failure.
*/

DWORD snwuLoadFile(const WCHAR* FileName, HANDLE Heap, SIZE_T* Size, LPVOID* Data);
/*
	Description
		Loads a file to memory.
	Parameters
		"FileName" Pointer to the starting of the string that contains the name of the file.
		"Heap" Heap used to allocate the memory using HeapAlloc. If this parameter is zero the allocation is allocated with VirtualAlloc using PAGE_READWRITE.
		"Size" Pointer to variable that receives the size of the file. If running on 32 bit system trying to map files larger than 4 GiB the function fails.
		"Data" Pointer to variable that receives pointer to the loaded file.
	Return value
		If the function succeeds, the return value is zero and windows error code on failure.
*/

DWORD snwuStoreFile(const WCHAR* FileName, SIZE_T Size, const LPVOID Data);
/*
	Description
		Stores block of data to file. If file exist that file is repleased.
	Parameters
		"FileName" Pointer to the starting of the string that contains the name of the file.
		"Size" Size of the data pinted be "Data" parameter.
		"Data" Pointer to the starting of data block to be stored in the file.
	Return value
		If the function succeeds, the return value is zero and windows error code on failure.
*/

DWORD snwuStoreBitmap(const WCHAR* FileName, SIZE_T Width, SIZE_T Height, SIZE_T Stride, const DWORD* Pixels);
/*
	Description
		Stores image to file in some format. If file exist that file is repleased.
	Parameters
		"FileName" Pointer to the starting of the string that contains the name of the file.
		"Width" Width on the image in pixels.
		"Height" Height on the image in pixels.
		"Stride" Image data stride in bytes.
		"Pixels" Pointer to the starting of image data.
	Return value
		If the function succeeds, the return value is zero and windows error code on failure.
*/

void snwuDrawTestImage(SIZE_T Width, SIZE_T Height, SIZE_T Stride, DWORD* Pixels);
/*
	Description
		Generates test image.
	Parameters
		"Width" Width on the image in pixels.
		"Height" Height on the image in pixels.
		"Stride" Image data stride in bytes.
		"Pixels" Pointer to the starting buffer that receives image data.
	Return value
		This function has no return value.
*/

#define SNWU_DIRECTORY_EXECUTABLE ((const WCHAR*)0x01)
#define SNWU_DIRECTORY_MODULE ((const WCHAR*)0x02)
#define SNWU_DIRECTORY_TEMPORAL ((const WCHAR*)0x03)
#define SNWU_DIRECTORY_SYSTEM ((const WCHAR*)0x04)
#define SNWU_DIRECTORY_FONTS ((const WCHAR*)0x05)
#define SNWU_DIRECTORY_USER ((const WCHAR*)0x06)
#define SNWU_DIRECTORY_DATA ((const WCHAR*)0x07)
#define SNWU_DIRECTORY_DESKTOP ((const WCHAR*)0x08)
#define SNWU_DIRECTORY_CURRENT ((const WCHAR*)0x09)
#define SNWU_DIRECTORY_DOCUMENTS ((const WCHAR*)0x0A)
#define SNWU_FILE_UNIQUE_TEMPORAL ((const WCHAR*)0x01)
DWORD snwuCreateFilePath(SIZE_T PathBufferSize, WCHAR* PathBuffer, const WCHAR* Directory, const WCHAR* File, SIZE_T* PathSize);
/*
	Description
		Combines directory and name to create path.
	Parameters
		"PathBufferSize" Size of buffer that receives the created file path in bytes
		"PathBuffer" Pointer to buffer that receives the created file path.
		"Directory" Pointer to the starting of the string that contains directory path that is used to begin the final path.
		This parameter can be also some sentinel values that specify some directory.
			SNWU_DIRECTORY_EXECUTABLE directory containing the executable of current process.
			SNWU_DIRECTORY_MODULE directory containing the module containing this function.
			SNWU_DIRECTORY_TEMPORAL directory for temporal files.
			SNWU_DIRECTORY_SYSTEM system directory.
			SNWU_DIRECTORY_FONTS windows font directory.
			SNWU_DIRECTORY_USER directory of current user.
			SNWU_DIRECTORY_DATA directory of current user data or system data.
			SNWU_DIRECTORY_DESKTOP desktop directory.
			SNWU_DIRECTORY_CURRENT current directory.
		"File" Pointer to the starting of the string that contains file name to be appended to the directory.
		If this parameter is SNWU_FILE_UNIQUE_TEMPORAL. random filename is used.
		"PathSize" Pointer to variable that receives size of the created path.
	Return value
		If the function succeeds, the return value is zero and windows error code on failure.
*/

#define SNWU_LIST_DIRECTORY_FLAG_LIST_SUBDIRECTORIES 0x00000001
#define SNWU_LIST_DIRECTORY_FLAG_IGNORE_DIRECTORIES 0x00000002
#define SNWU_LIST_DIRECTORY_FLAG_IGNORE_FILES 0x00000004
#define SNWU_LIST_DIRECTORY_FLAG_INCLUDE_ROOT_DIRECTORY 0x00000008
#define SNWU_LIST_DIRECTORY_FLAG_IGNORE_FIND_ACCESS_DENIED 0x00000010
DWORD snwuListDirectory(const WCHAR* DirectoryName, DWORD Flags, HANDLE Heap, SIZE_T* FileCount, WCHAR*** Files);
/*
	Description
		Lists contents of a directory to buffer that the function allocates.
	Parameters
		"DirectoryName" Pointer to the starting of the string that contains the name of the directory.
		"Flags" Flags that modify the behavior of the function.
			If SNWU_LIST_DIRECTORY_FLAG_LIST_SUBDIRECTORIES is set the directory and all subdirectories are listed recursively.
			If SNWU_LIST_DIRECTORY_FLAG_IGNORE_DIRECTORIES is set no directories are listed.
			If SNWU_LIST_DIRECTORY_FLAG_IGNORE_FILES is set no files are listed.
			if SNWU_LIST_DIRECTORY_FLAG_INCLUDE_ROOT_DIRECTORY is set the directory it self is included in the list. Must not be set with SNWU_LIST_DIRECTORY_FLAG_IGNORE_DIRECTORIES.
			If SNWU_LIST_DIRECTORY_FLAG_IGNORE_FIND_ACCESS_DENIED is set the function does not fail trying to list directories that listing fails with windows denying access.
		"Heap" Heap used to allocate the memory using HeapAlloc. If this parameter is zero the allocation is allocated with VirtualAlloc using PAGE_READWRITE.
		"FileCount" Pointer to buffer that receives number of files and directories listed. 
		"Files" Pointer to buffer that receives Pointer to buffer allocated by snwuListDirectory containing directory listing.
		The begining of buffer allocated by snwuListDirectory containins pointers to paths that are at the end of the buffer.
	Return value
		If the function succeeds, the return value is zero and windows error code on failure.
*/

DWORD snwuDeleteDirectory(const WCHAR* DirectoryName);
/*
	Description
		Deletes a directory and all subdirectories and files contained in the directory.
	Parameters
		"DirectoryName" Pointer to the starting of the string that contains the name of the directory.
	Return value
		If the function succeeds, the return value is zero and windows error code on failure.
*/

DWORD snwuCopyDirectory(const WCHAR* SourceDirectoryName, const WCHAR* DestinationDirectoryName);
/*
	Description
		Copies a directory with all of it's contents.
	Parameters
		"SourceDirectoryName" Pointer to the starting of the string that contains the name of directory to copied.
		"DestinationDirectoryName" Pointer to the starting of the string that contains the name of copy directory.
	Return value
		If the function succeeds, the return value is zero and windows error code on failure.
*/

DWORD snwuEnablePrivilege(const WCHAR* PrivilegeName, BOOL Enable);
/*
	Description
		Enables or disables a privilege on current process by name.
	Parameters
		"PrivilegeName" Pointer to the starting of the string that contains the name of the privilege.
		"Enable" If this parameter is nonzero the privilege is enables else it is disabled.
	Return value
		If the function succeeds, the return value is zero and windows error code on failure.
*/

DWORD snwuDeleteRegistryTree(HKEY ParentKey, const WCHAR* SubKey);
/*
	Description
		Deletes a registery tree.
	Parameters
		"ParentKey" A handle to an open registry key. 
		"SubKey" The name of the key to be deleted. It must be a subkey of the "ParentKey" parameter.
	Return value
		If the function succeeds, the return value is zero and windows error code on failure.
*/

DWORD snwuSelfDestruct();
/*
	Description
		Exits current process and deletes the executable file.
	Parameters
		This function has no parameters.
	Return value
		If the function succeeds, the return value is zero and windows error code on failure.
*/

typedef VOID* snwuFileInputStream;
// Opaque file input stream data type.

DWORD snwuOpenFileInputStream(const WCHAR* FileName, snwuFileInputStream* Stream, SIZE_T BufferSize, ULONGLONG* FileSize);
/*
	Description
		Opens an input stream for a file. File pointer is initially set to zero.
	Parameters
		"FileName" Pointer to the starting of the string that contains the name of the file.
		"Stream" Pointer to variable that receives Stream object.
		"BufferSize" Size for Stream object buffer to read the file. The stream object may contain multiple buffers.
		"FileSize" Pointer to variable that receives the size of the file.
	Return value
		If the function succeeds, the return value is zero and windows error code on failure.
*/

DWORD snwuSeekFileInputStream(snwuFileInputStream Stream, ULONGLONG Position);
/*
	Description
		Sets file pointer of file input stream.
	Parameters
		"Stream" File input stream.
		"Position" New file pointer for the stream.
	Return value
		If the function succeeds, the return value is zero and windows error code on failure.
*/

DWORD snwuReadFileInputStream(snwuFileInputStream Stream, SIZE_T* Size, VOID** Data);
/*
	Description
		Reads from file input stream.
	Parameters
		"Stream" File input stream.
		"Size" Pointer to the variable that receives the number of bytes read. Note that some times this funtion reads zero bytes.
		"Data" Pointer to receives address that points to the data read. This pointer is valid until the stream is read next time or closed.
	Return value
		If the function succeeds, the return value is zero and windows error code on failure.
*/

void snwuCloseFileInputStream(snwuFileInputStream Stream);
/*
	Description
		Closes file input stream.
	Parameters
		"Stream" File input stream to be closed.
	Return value
		This function has no return value.
*/

DWORD _snwuInternalHeapAlloc(HANDLE Heap, LPVOID* Allocation, SIZE_T* Size)
{
	LPVOID NewAllocation = HeapAlloc(Heap, 0, *Size);
	if (NewAllocation)
	{
		SIZE_T NewSize = HeapSize(Heap, 0, NewAllocation);
		if (NewSize != (SIZE_T)-1)
			*Size = NewSize;
		*Allocation = NewAllocation;
		return 0;
	}
	return GetLastError();
}

DWORD _snwuInternalHeapReAlloc(HANDLE Heap, LPVOID* Allocation, SIZE_T* Size)
{
	LPVOID NewAllocation = HeapReAlloc(Heap, 0, *Allocation, *Size);
	if (NewAllocation)
	{
		SIZE_T NewSize = HeapSize(Heap, 0, NewAllocation);
		if (NewSize != (SIZE_T)-1)
			*Size = NewSize;
		*Allocation = NewAllocation;
		return 0;
	}
	return GetLastError();
}

SIZE_T _snwuInternalCutLastComponentFromPathAndLeaveSlash(WCHAR* Path)
{
	WCHAR* Cut = 0;
	for (WCHAR* Read = Path[0] == L'\\' && Path[1] == L'\\' && Path[2] == L'?' && Path[3] == L'\\' ? Path + 4 : Path, Character = *Read++; Character; Character = *Read++)
		if (Character == L'\\' || Character == L'/')
			Cut = Read;
	if (!Cut || Cut == Path)
		Cut = Cut || Cut != Path ? Cut + 1 : Path;
	*Cut = 0;
	return (SIZE_T)((UINT_PTR)Cut - (UINT_PTR)Path);
}

SIZE_T _snwuInternalGetRootDirectoryNameSize(const WCHAR* Path)
{
	const WCHAR InvalidCharacters[9] = { L'<', L'>', L':', L'"', L'/', L'\\', L'|', L'?', L'*' };
	const WCHAR* ReadPath = Path;
	if (ReadPath[0] == L'\\' && ReadPath[1] == L'\\' && ReadPath[2] == L'?' && ReadPath[3] == L'\\')
	{
		const WCHAR* ReadComponent = ReadPath + 4;
		if (*ReadComponent > (WCHAR)31 &&
			*ReadComponent != InvalidCharacters[0] &&
			*ReadComponent != InvalidCharacters[1] &&
			*ReadComponent != InvalidCharacters[2] &&
			*ReadComponent != InvalidCharacters[3] &&
			*ReadComponent != InvalidCharacters[4] &&
			*ReadComponent != InvalidCharacters[5] &&
			*ReadComponent != InvalidCharacters[6] &&
			*ReadComponent != InvalidCharacters[7] &&
			*ReadComponent != InvalidCharacters[8] &&
			ReadComponent[1] == L':' &&  ReadComponent[2] == L'\\')
			ReadPath = ReadComponent + 3;
		else if (ReadComponent[0] == L'U' && ReadComponent[1] == L'N' && ReadComponent[2] == L'C' && ReadComponent[3] == L'\\')
		{
			ReadComponent += 4;
			const WCHAR* ReadComponentEnd = ReadComponent;
			while (*ReadComponentEnd > (WCHAR)31 &&
				*ReadComponentEnd != InvalidCharacters[0] &&
				*ReadComponentEnd != InvalidCharacters[1] &&
				*ReadComponentEnd != InvalidCharacters[2] &&
				*ReadComponentEnd != InvalidCharacters[3] &&
				*ReadComponentEnd != InvalidCharacters[4] &&
				*ReadComponentEnd != InvalidCharacters[5] &&
				*ReadComponentEnd != InvalidCharacters[6] &&
				*ReadComponentEnd != InvalidCharacters[7] &&
				*ReadComponentEnd != InvalidCharacters[8])
				++ReadComponentEnd;
			if (ReadComponent != ReadComponentEnd && *ReadComponentEnd == L'\\')
			{
				ReadComponent = ReadComponentEnd + 1;
				ReadComponentEnd = ReadComponent;
				while (*ReadComponentEnd > (WCHAR)31 &&
					*ReadComponentEnd != InvalidCharacters[0] &&
					*ReadComponentEnd != InvalidCharacters[1] &&
					*ReadComponentEnd != InvalidCharacters[2] &&
					*ReadComponentEnd != InvalidCharacters[3] &&
					*ReadComponentEnd != InvalidCharacters[4] &&
					*ReadComponentEnd != InvalidCharacters[5] &&
					*ReadComponentEnd != InvalidCharacters[6] &&
					*ReadComponentEnd != InvalidCharacters[7] &&
					*ReadComponentEnd != InvalidCharacters[8])
					++ReadComponentEnd;
				if (ReadComponent != ReadComponentEnd && *ReadComponentEnd == L'\\')
					ReadPath = ReadComponentEnd + 1;
			}
		}
	}
	else if (*ReadPath > (WCHAR)31 &&
		*ReadPath != InvalidCharacters[0] &&
		*ReadPath != InvalidCharacters[1] &&
		*ReadPath != InvalidCharacters[2] &&
		*ReadPath != InvalidCharacters[3] &&
		*ReadPath != InvalidCharacters[4] &&
		*ReadPath != InvalidCharacters[5] &&
		*ReadPath != InvalidCharacters[6] &&
		*ReadPath != InvalidCharacters[7] &&
		*ReadPath != InvalidCharacters[8] &&
		ReadPath[1] == L':' &&  ReadPath[2] == L'\\')
		ReadPath += 3;
	else if ((ReadPath[0] == L'\\' || ReadPath[0] == L'/') && (ReadPath[1] == L'\\' || ReadPath[1] == L'/'))
	{
		const WCHAR* ReadComponent = ReadPath + 2;
		const WCHAR* ReadComponentEnd = ReadComponent;
		while (*ReadComponentEnd > (WCHAR)31 &&
			*ReadComponentEnd != InvalidCharacters[0] &&
			*ReadComponentEnd != InvalidCharacters[1] &&
			*ReadComponentEnd != InvalidCharacters[2] &&
			*ReadComponentEnd != InvalidCharacters[3] &&
			*ReadComponentEnd != InvalidCharacters[4] &&
			*ReadComponentEnd != InvalidCharacters[5] &&
			*ReadComponentEnd != InvalidCharacters[6] &&
			*ReadComponentEnd != InvalidCharacters[7] &&
			*ReadComponentEnd != InvalidCharacters[8])
			++ReadComponentEnd;
		if (ReadComponent != ReadComponentEnd && (*ReadComponentEnd == L'\\' || *ReadComponentEnd == L'/'))
		{
			ReadComponent = ReadComponentEnd + 1;
			ReadComponentEnd = ReadComponent;
			while (*ReadComponentEnd > (WCHAR)31 &&
				*ReadComponentEnd != InvalidCharacters[0] &&
				*ReadComponentEnd != InvalidCharacters[1] &&
				*ReadComponentEnd != InvalidCharacters[2] &&
				*ReadComponentEnd != InvalidCharacters[3] &&
				*ReadComponentEnd != InvalidCharacters[4] &&
				*ReadComponentEnd != InvalidCharacters[5] &&
				*ReadComponentEnd != InvalidCharacters[6] &&
				*ReadComponentEnd != InvalidCharacters[7] &&
				*ReadComponentEnd != InvalidCharacters[8])
				++ReadComponentEnd;
			if (ReadComponent != ReadComponentEnd && (*ReadComponentEnd == L'\\' || *ReadComponentEnd == L'/'))
				ReadPath = ReadComponentEnd + 1;
		}
	}
	return (SIZE_T)((UINT_PTR)ReadPath - (UINT_PTR)Path);
}

SIZE_T _snwuInternalCutSlashAndLastComponentFromPath(WCHAR* Path)
{
	WCHAR* ReadPath = Path;
	WCHAR* Cut = (WCHAR*)((UINT_PTR)ReadPath + (UINT_PTR)_snwuInternalGetRootDirectoryNameSize(ReadPath));
	for (WCHAR Character = *ReadPath++; Character; Character = *ReadPath++)
		if (Character == L'\\' || Character == L'/')
			Cut = ReadPath - 1;
	*Cut = 0;
	return (SIZE_T)((UINT_PTR)Cut - (UINT_PTR)Path);
}

#define _SNWU_INTERNAL_INPUT_PATH_SIZE_LIMIT (0x10000 * sizeof(WCHAR))
#define _SNWU_INTERNAL_FILE_INPUT_STRAM_STATUS_IDLE 0
#define _SNWU_INTERNAL_FILE_INPUT_STRAM_STATUS_STREAM 1
#define _SNWU_INTERNAL_FILE_INPUT_STRAM_STATUS_ERROR 2
#define _SNWU_INTERNAL_FILE_INPUT_STRAM_BUFFER_ALIGNMENT 64
typedef struct _snwuInternalFileInputStream
{
	OVERLAPPED Overlapped;
	ULONGLONG FileSize;
	ULONGLONG FilePointer;
	HANDLE FileHandle;
	SIZE_T BufferSize;
	LPVOID FrontBuffer;
	LPVOID BackBuffer;
	DWORD Status;
	HANDLE Heap;
} _snwuInternalFileInputStream;

#ifdef _M_X64

#include <immintrin.h>

void snwuClear(VOID* Memory, SIZE_T Size)
{
	if (Size < sizeof(__m128i))
	{
		for (VOID* MemoryEnd = (VOID*)((UINT_PTR)Memory + Size); Memory != MemoryEnd; Memory = (VOID*)((UINT_PTR)Memory + 1))
			*(BYTE*)Memory = 0;
		return;
	}
	__m128i DataBlock = _mm_setzero_si128();
	if ((UINT_PTR)Memory & (sizeof(__m128i) - 1))
	{
		UINT_PTR AligmentFix = sizeof(__m128i) - ((UINT_PTR)Memory & (sizeof(__m128i) - 1));
		_mm_storeu_si128((__m128i*)Memory, DataBlock);
		Memory = (VOID*)((UINT_PTR)Memory + AligmentFix);
		Size -= AligmentFix;
	}
	for (VOID* MemoryEnd = (VOID*)((UINT_PTR)Memory + (Size & ~(sizeof(__m128i) - 1))); Memory != MemoryEnd; Memory = (VOID*)((UINT_PTR)Memory + sizeof(__m128i)))
		_mm_store_si128((__m128i*)Memory, DataBlock);
	for (VOID* MemoryEnd = (VOID*)((UINT_PTR)Memory + (Size & (sizeof(__m128i) - 1))); Memory != MemoryEnd; Memory = (VOID*)((UINT_PTR)Memory + 1))
		*(BYTE*)Memory = 0;
}

void snwuCopy(const VOID* Source, VOID* Destination, SIZE_T Size)
{
	if (Size < sizeof(__m128i))
	{
		for (const VOID* SourceEnd = (const VOID*)((UINT_PTR)Source + Size); Source != SourceEnd; Source = (const VOID*)((UINT_PTR)Source + 1), Destination = (VOID*)((UINT_PTR)Destination + 1))
			*(BYTE*)Destination = *(const BYTE*)Source;
		return;
	}
	__m128i DataBlock;
	if (((UINT_PTR)Destination & (sizeof(__m128i) - 1)) == ((UINT_PTR)Source & (sizeof(__m128i) - 1)))
	{
		if ((UINT_PTR)Source & (sizeof(__m128i) - 1))
		{
			UINT_PTR AligmentFix = sizeof(__m128i) - ((UINT_PTR)Source & (sizeof(__m128i) - 1));
			DataBlock = _mm_loadu_si128((const __m128i*)Source);
			_mm_storeu_si128((__m128i*)Destination, DataBlock);
			Source = (const VOID*)((UINT_PTR)Source + AligmentFix);
			Destination = (VOID*)((UINT_PTR)Destination + AligmentFix);
			Size -= AligmentFix;
		}
		for (const VOID* SourceEnd = (const VOID*)((UINT_PTR)Source + ((UINT_PTR)Size & ~(sizeof(__m128i) - 1))); Source != SourceEnd; Source = (const VOID*)((UINT_PTR)Source + sizeof(__m128i)), Destination = (VOID*)((UINT_PTR)Destination + sizeof(__m128i)))
		{
			DataBlock = _mm_load_si128((const __m128i*)Source);
			_mm_store_si128((__m128i*)Destination, DataBlock);
		}
	}
	else
		for (const VOID* SourceEnd = (const VOID*)((UINT_PTR)Source + ((UINT_PTR)Size & ~(sizeof(__m128i) - 1))); Source != SourceEnd; Source = (const VOID*)((UINT_PTR)Source + sizeof(__m128i)), Destination = (VOID*)((UINT_PTR)Destination + sizeof(__m128i)))
		{
			DataBlock = _mm_loadu_si128((const __m128i*)Source);
			_mm_storeu_si128((__m128i*)Destination, DataBlock);
		}
	for (const VOID* SourceEnd = (VOID*)((UINT_PTR)Source + ((UINT_PTR)Size & (sizeof(__m128i) - 1))); Source != SourceEnd; Source = (const VOID*)((UINT_PTR)Source + 1), Destination = (VOID*)((UINT_PTR)Destination + 1))
		*(BYTE*)Destination = *(const BYTE*)Source;
}

void snwuMove(VOID* Source, VOID* Destination, SIZE_T Size)
{
	__m128i DataBlock;
	if ((UINT_PTR)Source > (UINT_PTR)Destination)
	{
		BYTE* S = (BYTE*)Source;
		BYTE* D = (BYTE*)Destination;
		if (Size < sizeof(__m128i))
		{
			BYTE* E = S + Size;
			while (S != E)
				*D++ = *S++;
			return;
		}
		UINT_PTR AligmentFix = sizeof(__m128i) - ((UINT_PTR)S & (sizeof(__m128i) - 1));
		Size -= AligmentFix;
		BYTE* E = S + AligmentFix;
		while (S != E)
			*D++ = *S++;
		E = S + (Size & ~(sizeof(__m128i) - 1));
		if ((UINT_PTR)D & (sizeof(__m128i) - 1))
			while (S != E)
			{
				DataBlock = _mm_load_si128((const __m128i*)S);
				_mm_storeu_si128((__m128i*)D, DataBlock);
				S += sizeof(__m128i);
				D += sizeof(__m128i);
			}
		else
			while (S != E)
			{
				DataBlock = _mm_load_si128((const __m128i*)S);
				_mm_store_si128((__m128i*)D, DataBlock);
				S += sizeof(__m128i);
				D += sizeof(__m128i);
			}
		E = S + (Size & (sizeof(__m128i) - 1));
		while (S != E)
			*D++ = *S++;
	}
	else if ((UINT_PTR)Source < (UINT_PTR)Destination)
	{
		BYTE* S = (BYTE*)Source + Size;
		BYTE* D = (BYTE*)Destination + Size;
		if (Size < sizeof(__m128i))
		{
			BYTE* E = S - Size;
			while (S != E)
				*--D = *--S;
			return;
		}
		UINT_PTR AligmentFix = (UINT_PTR)S & (sizeof(__m128i) - 1);
		Size -= AligmentFix;
		BYTE* E = S - AligmentFix;
		while (S != E)
			*--D = *--S;
		E = S - (Size & ~(sizeof(__m128i) - 1));
		if ((UINT_PTR)D & (sizeof(__m128i) - 1))
			while (S != E)
			{
				S -= sizeof(__m128i);
				D -= sizeof(__m128i);
				DataBlock = _mm_load_si128((const __m128i*)S);
				_mm_storeu_si128((__m128i*)D, DataBlock);
			}
		else
			while (S != E)
			{
				S -= sizeof(__m128i);
				D -= sizeof(__m128i);
				DataBlock = _mm_load_si128((const __m128i*)S);
				_mm_store_si128((__m128i*)D, DataBlock);
			}
		E = S - (Size & (sizeof(__m128i) - 1));
		while (S != E)
			*--D = *--S;
	}
}

#else

void snwuClear(VOID* Memory, SIZE_T Size)
{
	if (Size < sizeof(UINT_PTR))
	{
		for (VOID* MemoryEnd = (VOID*)((UINT_PTR)Memory + Size); Memory != MemoryEnd; Memory = (VOID*)((UINT_PTR)Memory + 1))
			*(BYTE*)Memory = 0;
		return;
	}
	for (VOID* MemoryEnd = (VOID*)((UINT_PTR)Memory + ((UINT_PTR)Memory & (sizeof(UINT_PTR) - 1))); Memory != MemoryEnd; Memory = (VOID*)((UINT_PTR)Memory + 1), --Size)
		*(BYTE*)Memory = 0;
	for (VOID* MemoryEnd = (VOID*)((UINT_PTR)Memory + ((UINT_PTR)Size & ~(sizeof(UINT_PTR) - 1))); Memory != MemoryEnd; Memory = (VOID*)((UINT_PTR)Memory + sizeof(UINT_PTR)))
		*(UINT_PTR*)Memory = 0;
	for (VOID* MemoryEnd = (VOID*)((UINT_PTR)Memory + ((UINT_PTR)Size & (sizeof(UINT_PTR) - 1))); Memory != MemoryEnd; Memory = (VOID*)((UINT_PTR)Memory + 1))
		*(BYTE*)Memory = 0;
};

void snwuCopy(const VOID* Source, VOID* Destination, SIZE_T Size)
{
	if (Size < sizeof(UINT_PTR))
	{
		for (const VOID* SourceEnd = (const VOID*)((UINT_PTR)Source + Size); Source != SourceEnd; Source = (const VOID*)((UINT_PTR)Source + 1), Destination = (VOID*)((UINT_PTR)Destination + 1))
			*(BYTE*)Destination = *(const BYTE*)Source;
		return;
	}
	if (((UINT_PTR)Destination & (sizeof(UINT_PTR) - 1)) == ((UINT_PTR)Source & (sizeof(UINT_PTR) - 1)))
	{
		for (const VOID* SourceEnd = (const VOID*)((UINT_PTR)Source + ((UINT_PTR)Source & (sizeof(UINT_PTR) - 1))); Source != SourceEnd; Source = (const VOID*)((UINT_PTR)Source + 1), Destination = (VOID*)((UINT_PTR)Destination + 1), --Size)
			*(BYTE*)Destination = *(const BYTE*)Source;
		for (const VOID* SourceEnd = (const VOID*)((UINT_PTR)Source + ((UINT_PTR)Size & ~(sizeof(UINT_PTR) - 1))); Source != SourceEnd; Source = (const VOID*)((UINT_PTR)Source + sizeof(UINT_PTR)), Destination = (VOID*)((UINT_PTR)Destination + sizeof(UINT_PTR)))
			*(UINT_PTR*)Destination = *(const UINT_PTR*)Source;
		for (const VOID* SourceEnd = (const VOID*)((UINT_PTR)Source + ((UINT_PTR)Size & (sizeof(UINT_PTR) - 1))); Source != SourceEnd; Source = (const VOID*)((UINT_PTR)Source + 1), Destination = (VOID*)((UINT_PTR)Destination + 1))
			*(BYTE*)Destination = *(const BYTE*)Source;
		return;
	}
	for (const VOID* SourceEnd = (const VOID*)((UINT_PTR)Source + Size); Source != SourceEnd; Source = (const VOID*)((UINT_PTR)Source + 1), Destination = (VOID*)((UINT_PTR)Destination + 1))
		*(BYTE*)Destination = *(const BYTE*)Source;
}

void snwuMove(VOID* Source, VOID* Destination, SIZE_T Size)
{
	if ((UINT_PTR)Source > (UINT_PTR)Destination)
	{
		BYTE* S = (BYTE*)Source;
		BYTE* D = (BYTE*)Destination;
		if (((UINT_PTR)S & (sizeof(UINT_PTR) - 1)) != ((UINT_PTR)D & (sizeof(UINT_PTR) - 1)) || Size < sizeof(UINT_PTR))
		{
			BYTE* E = S + Size;
			while (S != E)
				*D++ = *S++;
			return;
		}
		UINT_PTR AligmentFix = sizeof(UINT_PTR) - ((UINT_PTR)S & (sizeof(UINT_PTR) - 1));
		Size -= AligmentFix;
		BYTE* E = S + AligmentFix;
		while (S != E)
			*D++ = *S++;
		E = S + (Size & ~(sizeof(UINT_PTR) - 1));
		while (S != E)
		{
			*(UINT_PTR*)D = *(UINT_PTR*)S;
			S += sizeof(UINT_PTR);
			D += sizeof(UINT_PTR);
		}
		E = S + (Size & (sizeof(UINT_PTR) - 1));
		while (S != E)
			*D++ = *S++;
	}
	else if ((UINT_PTR)Source < (UINT_PTR)Destination)
	{
		BYTE* S = (BYTE*)Source + Size;
		BYTE* D = (BYTE*)Destination + Size;
		if (((UINT_PTR)S & (sizeof(UINT_PTR) - 1)) != ((UINT_PTR)D & (sizeof(UINT_PTR) - 1)) || Size < sizeof(UINT_PTR))
		{
			BYTE* E = S - Size;
			while (S != E)
				*--D = *--S;
			return;
		}
		UINT_PTR AligmentFix = (UINT_PTR)S & (sizeof(UINT_PTR) - 1);
		Size -= AligmentFix;
		BYTE* E = S - AligmentFix;
		while (S != E)
			*--D = *--S;
		E = S - (Size & ~(sizeof(UINT_PTR) - 1));
		while (S != E)
		{
			S -= sizeof(UINT_PTR);
			D -= sizeof(UINT_PTR);
			*(UINT_PTR*)D = *(UINT_PTR*)S;
		}
		E = S - (Size & (sizeof(UINT_PTR) - 1));
		while (S != E)
			*--D = *--S;
	}
}

#endif

void snwuInitializeMutex(volatile snwuMutex* Mutex)
{
	HMODULE Kernel32 = GetModuleHandleW(L"Kernel32.dll");
	if (Kernel32)
	{
		Mutex->_WaitOnAddress = (BOOL (WINAPI*)(VOID volatile*, PVOID, SIZE_T, DWORD))GetProcAddress(Kernel32, "WaitOnAddress");
		Mutex->_WakeByAddressAll = (VOID (WINAPI*)(PVOID))GetProcAddress(Kernel32, "WakeByAddressAll");
		if (!Mutex->_WaitOnAddress || !Mutex->_WakeByAddressAll)
		{
			Mutex->_WaitOnAddress = 0;
			Mutex->_WakeByAddressAll = 0;
		}
	}
	else
	{
		Mutex->_WaitOnAddress = 0;
		Mutex->_WakeByAddressAll = 0;
	}
	Mutex->_LatestOwner = (LONG)-1;
	MemoryBarrier();
	Mutex->_CurrentOwner = 0;
}

void snwuAcquireMutex(volatile snwuMutex* Mutex)
{
	BOOL (WINAPI* WaitOnAddress)(VOID volatile* Address, PVOID CompareAddress, SIZE_T AddressSize, DWORD dwMilliseconds) = Mutex->_WaitOnAddress;
	LONG ThisOwnerIdentity = InterlockedIncrement(&Mutex->_LatestOwner);
	LONG CurrentOwner = Mutex->_CurrentOwner;
	if (WaitOnAddress)
		while (ThisOwnerIdentity != CurrentOwner)
		{
			WaitOnAddress(&Mutex->_CurrentOwner, (PVOID)&CurrentOwner, sizeof(LONG), INFINITE);
			CurrentOwner = Mutex->_CurrentOwner;
		}
	else
		while (ThisOwnerIdentity != CurrentOwner)
		{
			Sleep(0);
			CurrentOwner = Mutex->_CurrentOwner;
		}
}

void snwuReleaseMutex(volatile snwuMutex* Mutex)
{
	LONG BeginReleaseLatestOwner = Mutex->_LatestOwner;
	LONG BeginReleaseCurrentOwner = Mutex->_CurrentOwner;
	VOID (WINAPI* WakeByAddressAll)(PVOID Address) = Mutex->_WakeByAddressAll;
	InterlockedIncrement(&Mutex->_CurrentOwner);
	if (WakeByAddressAll && (BeginReleaseLatestOwner != BeginReleaseCurrentOwner || BeginReleaseLatestOwner != Mutex->_LatestOwner))
		WakeByAddressAll((PVOID)&Mutex->_CurrentOwner);
}

#ifdef _M_X64

SIZE_T snwuStringSize(const WCHAR* String)
{
	const WCHAR* End = String;
	while ((UINT_PTR)End & (sizeof(__m128i) - 1))
		if (!*End++)
			return (SIZE_T)((UINT_PTR)End - (UINT_PTR)String);
	for (__m128i ZeroDataBlock = _mm_setzero_si128(), DataBlock, DataMaskBlock;; End = (const WCHAR*)((UINT_PTR)End + sizeof(__m128i)))
	{
		DataBlock = _mm_load_si128((const __m128i*)End);
		DataMaskBlock = _mm_cmpeq_epi16(DataBlock, ZeroDataBlock);
		int SignificantBits = _mm_movemask_epi8(DataMaskBlock);
		if (SignificantBits)
		{
			unsigned long BitIndex;
			_BitScanForward(&BitIndex, (unsigned long)SignificantBits & 0x5555);
			return (SIZE_T)((UINT_PTR)End - (UINT_PTR)String) + (SIZE_T)BitIndex + sizeof(WCHAR);
		}
	}
}

#else

SIZE_T snwuStringSize(const WCHAR* String)
{
	const WCHAR* End = String;
	while (*End)
		++End;
	return (SIZE_T)((UINT_PTR)End - (UINT_PTR)String) + sizeof(WCHAR);
}

#endif

BOOL snwuCompareStrings(const WCHAR* String0, const WCHAR* String1)
{
	while (*String0 && *String0 == *String1)
	{
		++String0;
		++String1;
	}
	return !*String1;
}

DWORD snwuGetRandomSeed()
{
	const WCHAR* RegistryValueName = L"ThreadRandomSubSeed";
	WCHAR RegistrySubKeyName[36] = L"Software\\Santtu Nyman\\SNWU\\\0\0\0\0\0\0\0\0";
	DWORD ThreadIdentity = GetCurrentThreadId();
	for (DWORD Index = 0; Index != 8; ++Index)
		RegistrySubKeyName[27 + Index] = L"0123456789ABCDEF"[(ThreadIdentity >> ((7 - Index) << 2)) & 0xF];
	DWORD ThreadRandomSubSeed;
	HKEY RegistryKey;
	if (!RegCreateKeyExW(HKEY_CURRENT_USER, RegistrySubKeyName, 0, 0, REG_OPTION_VOLATILE, KEY_QUERY_VALUE | KEY_SET_VALUE, 0, &RegistryKey, 0))
	{
		DWORD RegistryValueType;
		DWORD RegistryValueSize = sizeof(DWORD);
		BOOL Initialize = !RegQueryValueExW(RegistryKey, RegistryValueName, 0, &RegistryValueType, (LPBYTE)&ThreadRandomSubSeed, &RegistryValueSize);
		if (Initialize)
		{
			if (RegistryValueType == REG_DWORD && RegistryValueSize == sizeof(DWORD))
				ThreadRandomSubSeed += GetTickCount() + 1;
			else
			{
				RegDeleteValueW(RegistryKey, RegistryValueName);
				Initialize = FALSE;
			}
		}
		if (!Initialize)
		{
			HMODULE Advapi32 = LoadLibraryW(L"Advapi32.dll");
			BOOLEAN (WINAPI* RtlGenRandom)(PVOID RandomBuffer, ULONG RandomBufferLength) = Advapi32 ? (BOOLEAN (WINAPI*)(PVOID, ULONG))GetProcAddress(Advapi32, "SystemFunction036") : 0;
			if (!RtlGenRandom || !RtlGenRandom(&ThreadRandomSubSeed, sizeof(DWORD)))
				QueryPerformanceCounter((LARGE_INTEGER*)&ThreadRandomSubSeed);
			if (Advapi32)
				FreeLibrary(Advapi32);
			ThreadRandomSubSeed ^= ThreadIdentity;
		}
		RegSetValueExW(RegistryKey, RegistryValueName, 0, REG_DWORD, (const BYTE*)&ThreadRandomSubSeed, sizeof(DWORD));
		RegCloseKey(RegistryKey);
	}
	FILETIME Entropy[2];
	GetSystemTimeAsFileTime(Entropy);
#ifdef _M_X64
	*(unsigned __int64*)(Entropy + 1) = __rdtsc();
#elif _M_IX86
	*(unsigned __int64*)(Entropy + 1) = __rdtsc();
#else
	QueryPerformanceCounter((LARGE_INTEGER*)(Entropy + 1));
#endif
	DWORD Hash = 0xFFFFFFFF;
	for (const BYTE* DataPointer = (const BYTE*)Entropy, *DataEndPointer = (const BYTE*)((UINT_PTR)DataPointer + (2 * sizeof(FILETIME))); DataPointer != DataEndPointer; ++DataPointer)
	{
		Hash = Hash ^ (DWORD)*DataPointer;
		for (SIZE_T i = 8; i--;)
			Hash = (Hash >> 1) ^ (0xEDB88320 & (0 - (Hash & 1)));
	}
	return ~Hash ^ ThreadRandomSubSeed;
}

DWORD snwuPrint(const WCHAR* Text, BOOL NewLine)
{
	HANDLE ConsoleOut = CreateFileW(L"CONOUT$", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, 0, OPEN_EXISTING, 0, 0);
	if (ConsoleOut == INVALID_HANDLE_VALUE)
		return GetLastError();
	DWORD ConsoleWritteResult;
	for (SIZE_T StringLength = (snwuStringSize(Text) / sizeof(WCHAR)) - 1, ConsoleWritten = 0; StringLength != ConsoleWritten;)
	{
		if (!WriteConsoleW(ConsoleOut, Text + ConsoleWritten, (DWORD)((StringLength - ConsoleWritten) < 0xFFFFFFFF ? (StringLength - ConsoleWritten) : 0xFFFFFFFF), &ConsoleWritteResult, 0))
		{
			DWORD Error = GetLastError();
			CloseHandle(ConsoleOut);
			return Error;
		}
		else
			ConsoleWritten += (SIZE_T)ConsoleWritteResult;
	}
	if (NewLine)
		if (!WriteConsoleW(ConsoleOut, L"\n", 1, &ConsoleWritteResult, 0))
		{
			DWORD Error = GetLastError();
			CloseHandle(ConsoleOut);
			return Error;
		}
	CloseHandle(ConsoleOut);
	return 0;
}

DWORD snwuShowError(DWORD Error)
{
	SYSTEM_INFO SystemInfo;
	GetNativeSystemInfo(&SystemInfo);
	SIZE_T FormatMessageMaxBufferSize = 0x10000;
	WCHAR* ErrorMessage = (WCHAR*)VirtualAlloc(0, SystemInfo.dwPageSize ? (((((21 * sizeof(WCHAR)) + FormatMessageMaxBufferSize) + (SystemInfo.dwPageSize - 1)) / (SystemInfo.dwPageSize)) * SystemInfo.dwPageSize) : ((21 * sizeof(WCHAR)) + FormatMessageMaxBufferSize), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	if (!ErrorMessage)
	{
		FormatMessageMaxBufferSize = (SIZE_T)SystemInfo.dwPageSize;
		WCHAR* ErrorMessage = (WCHAR*)VirtualAlloc(0, SystemInfo.dwPageSize ? (((((21 * sizeof(WCHAR)) + FormatMessageMaxBufferSize) + (SystemInfo.dwPageSize - 1)) / (SystemInfo.dwPageSize)) * SystemInfo.dwPageSize) : ((21 * sizeof(WCHAR)) + FormatMessageMaxBufferSize), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
		if (!ErrorMessage)
			return GetLastError();
	}
	ErrorMessage[0] = L'E';
	ErrorMessage[1] = L'R';
	ErrorMessage[2] = L'R';
	ErrorMessage[3] = L'O';
	ErrorMessage[4] = L'R';
	ErrorMessage[5] = L' ';
	ErrorMessage[6] = L'0';
	ErrorMessage[7] = L'x';
	for (DWORD Index = 0; Index != 8; ++Index)
		ErrorMessage[8 + Index] = L"0123456789ABCDEF"[(Error >> ((7 - Index) << 2)) & 0xF];
	ErrorMessage[16] = L' ';
	ErrorMessage[17] = L'\"';
	SIZE_T FormatMessageLength = (SIZE_T)FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, 0, Error, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), &ErrorMessage[18], (DWORD)(FormatMessageMaxBufferSize / sizeof(WCHAR)), 0);
	if (!FormatMessageLength)
	{
		DWORD LastError = GetLastError();
		VirtualFree(ErrorMessage, 0, MEM_RELEASE);
		return LastError;
	}
	while (FormatMessageLength && (ErrorMessage[17 + FormatMessageLength] < (WCHAR)0x21))
		--FormatMessageLength;
	ErrorMessage[18 + FormatMessageLength] = L'\"';
	ErrorMessage[19 + FormatMessageLength] = L'\n';
	ErrorMessage[20 + FormatMessageLength] = 0;
	OutputDebugStringW(ErrorMessage);
	HANDLE ConsoleOut = CreateFileW(L"CONOUT$", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_WRITE, 0, OPEN_EXISTING, 0, 0);
	if (ConsoleOut != INVALID_HANDLE_VALUE)
	{
		DWORD ConsoleWriteLenght = (DWORD)(20 + FormatMessageLength);
		WriteConsoleW(ConsoleOut, ErrorMessage, ConsoleWriteLenght, &ConsoleWriteLenght, 0);
		CloseHandle(ConsoleOut);
	}
	VirtualFree(ErrorMessage, 0, MEM_RELEASE);
	return 0;
}

DWORD snwuCreateFileWithRandomName(HANDLE* Handle, DWORD Access, DWORD ShareMode, BOOL IsDirectory, BOOL DoNotCreate, WCHAR* Path, const WCHAR* Extension)
{
	const WCHAR NameCharecters[32] = {
		L'0', L'1', L'2', L'3', L'4', L'5', L'6', L'7',
		L'8', L'9', L'A', L'B', L'C', L'D', L'E', L'F',
		L'G', L'H', L'I', L'J', L'K', L'L', L'M', L'N',
		L'O', L'P', L'Q', L'R', L'S', L'T', L'U', L'V' };
	SIZE_T PathSize = snwuStringSize(Path);
	WCHAR* Name = PathSize ? (WCHAR*)((UINT_PTR)Path + PathSize - sizeof(WCHAR)) : Path;
	if (PathSize && *(Name - 1) != L'\\' && *(Name - 1) != L'/')
		*Name++ = L'\\';
	if (Extension)
	{
		WCHAR* Write = Name + 8;
		while (*Extension)
			*Write++ = *Extension++;
		*Write = 0;
	}
	else
		*(Name + 8) = 0;
	*Name = NameCharecters[((GetTickCount() >> 4) + PathSize) & 0x1F];
	HANDLE FileHandle = INVALID_HANDLE_VALUE;
	for (DWORD Error = ERROR_FILE_EXISTS, FileIdentity = snwuGetRandomSeed(), Loop = 0; Error; ++Loop)
	{
		for (DWORD IterationFileIdentity = FileIdentity + Loop, Digit = 0; Digit != 7; ++Digit)
			Name[1 + Digit] = NameCharecters[(IterationFileIdentity >> ((6 - Digit) * 5)) & 0x1F];
		if (DoNotCreate)
		{
			if (GetFileAttributesW(Path) == INVALID_FILE_ATTRIBUTES)
				return 0;
		}
		else
		{
			if (IsDirectory)
			{
				if (CreateDirectoryW(Path, 0))
				{
					if (Handle)
					{
						FileHandle = CreateFileW(Path, Access, ShareMode, 0, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, 0);
						if (FileHandle != INVALID_HANDLE_VALUE)
							Error = 0;
						else
						{
							Error = GetLastError();
							RemoveDirectoryW(Path);
						}
					}
					else
						Error = 0;
				}
				else
					Error = GetLastError();
			}
			else
			{
				FileHandle = CreateFileW(Path, Access, ShareMode, 0, CREATE_NEW, 0, 0);
				if (FileHandle != INVALID_HANDLE_VALUE)
				{
					if (!Handle)
						CloseHandle(FileHandle);
					Error = 0;
				}
				else
					Error = GetLastError();
			}
		}
		if (Error && (Error != ERROR_FILE_EXISTS || Loop == 0xFFFFFFFF))
		{
			*(Name - 1) = 0;
			return Error;
		}
	}
	if (!DoNotCreate && Handle)
		*Handle = FileHandle;
	return 0;
}

DWORD snwuMapFile(const WCHAR* FileName, DWORD PageProtection, SIZE_T* Size, LPVOID* Mapping, BOOL Prefetch)
{
	DWORD FileAccess;
	DWORD FileShare;
	DWORD ViewAccess;
	switch (PageProtection)
	{
		case PAGE_EXECUTE_READ:
			FileAccess = GENERIC_READ | GENERIC_EXECUTE;
			FileShare = FILE_SHARE_READ;
			ViewAccess = FILE_MAP_READ | FILE_MAP_EXECUTE;
			break;
		case PAGE_EXECUTE_READWRITE:
			FileAccess = GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE;
			FileShare = 0;
			ViewAccess = FILE_MAP_WRITE | FILE_MAP_READ | FILE_MAP_EXECUTE;
			break;
		case PAGE_EXECUTE_WRITECOPY:
			FileAccess = GENERIC_WRITE | GENERIC_EXECUTE;
			FileShare = 0;
			ViewAccess = FILE_MAP_COPY | FILE_MAP_WRITE | FILE_MAP_EXECUTE;
			break;
		case PAGE_READONLY:
			FileAccess = GENERIC_READ;
			FileShare = FILE_SHARE_READ;
			ViewAccess = FILE_MAP_READ;
			break;
		case PAGE_READWRITE:
			FileAccess = GENERIC_READ | GENERIC_WRITE;
			FileShare = 0;
			ViewAccess = FILE_MAP_WRITE;
			break;
		case PAGE_WRITECOPY:
			FileAccess = GENERIC_WRITE;
			FileShare = 0;
			ViewAccess = FILE_MAP_COPY | FILE_MAP_WRITE;
			break;
		default:
			return ERROR_INVALID_PARAMETER;
	}
	HANDLE File = CreateFileW(FileName, FileAccess, FileShare, 0, OPEN_EXISTING, 0, 0);
	if (File == INVALID_HANDLE_VALUE)
		return GetLastError();
	ULARGE_INTEGER FileSize;
	if (!GetFileSizeEx(File, (LARGE_INTEGER*)&FileSize))
	{
		DWORD Error = GetLastError();
		CloseHandle(File);
		return Error;
	}
#ifndef __WIN64
	if (FileSize.HighPart)
	{
		CloseHandle(File);
		return ERROR_FILE_TOO_LARGE;
	}
#endif
	HANDLE View = CreateFileMappingW(File, 0, PageProtection, FileSize.HighPart, FileSize.LowPart, 0);
	if (!View)
	{
		DWORD Error = GetLastError();
		CloseHandle(File);
		return Error;
	}
#ifndef __WIN64
	LPVOID Address = MapViewOfFile(View, ViewAccess, 0, 0, (SIZE_T)FileSize.LowPart);
#else
	LPVOID Address = MapViewOfFile(View, ViewAccess, 0, 0, (SIZE_T)FileSize.QuadPart);
#endif
	DWORD Error = Address ? 0 : GetLastError();
	CloseHandle(View);
	CloseHandle(File);
#ifndef __WIN64
	*Size = (SIZE_T)FileSize.LowPart;
#else
	*Size = (SIZE_T)FileSize.QuadPart;
#endif
	if (Prefetch)
	{
		HMODULE Kernel32 = GetModuleHandleW(L"Kernel32.dll");
		BOOL (WINAPI* PrefetchVirtualMemory)(HANDLE hProcess, ULONG_PTR NumberOfEntries, UINT_PTR* VirtualAddresses, ULONG Flags) = Kernel32 ? (BOOL (WINAPI*)(HANDLE, ULONG_PTR, UINT_PTR*, ULONG))GetProcAddress(Kernel32, "PrefetchVirtualMemory") : 0;
		if (PrefetchVirtualMemory)
		{
			UINT_PTR FileMemory[2] = { (UINT_PTR)Address, *Size };
			if (PrefetchVirtualMemory(GetCurrentProcess(), 1, FileMemory, 0))
				Prefetch = FALSE;
		}
		if (Prefetch && PageProtection != PAGE_EXECUTE_WRITECOPY && PageProtection != PAGE_WRITECOPY)
		{
			SYSTEM_INFO SystemInfo;
			GetNativeSystemInfo(&SystemInfo);
			volatile BYTE VolatileLoadValue;
			for (UINT_PTR PageSize = (UINT_PTR)SystemInfo.dwPageSize, PrefetchPointer = (UINT_PTR)Address, PrefetchPointerEnd = PrefetchPointer + ((*Size + PageSize - 1) & ~(PageSize - 1)); PrefetchPointer != PrefetchPointerEnd; PrefetchPointer += PageSize)
				VolatileLoadValue = *(volatile BYTE*)PrefetchPointer;
		}
	}
	*Mapping = Address;
	return Error;
}

DWORD snwuLoadFile(const WCHAR* FileName, HANDLE Heap, SIZE_T* Size, LPVOID* Data)
{
	HANDLE FileHandle = CreateFileW(FileName, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, 0);
	DWORD Error;
	SIZE_T FileSize;
#ifdef _WIN64
	if (!GetFileSizeEx(FileHandle, (LARGE_INTEGER*)&FileSize))
	{
		Error = GetLastError();
		CloseHandle(FileHandle);
		return Error;
	}
#else
	ULARGE_INTEGER RawFileSize;
	if (!GetFileSizeEx(FileHandle, (LARGE_INTEGER*)&RawFileSize))
	{
		Error = GetLastError();
		CloseHandle(FileHandle);
		return Error;
	}
	if (RawFileSize.HighPart)
	{
		CloseHandle(FileHandle);
		return ERROR_FILE_TOO_LARGE;
	}
	FileSize = (SIZE_T)RawFileSize.LowPart;
#endif
	UINT_PTR FileData = Heap ? (UINT_PTR)HeapAlloc(Heap, 0, FileSize) : (UINT_PTR)VirtualAlloc(0, FileSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	if (!FileData)
	{
		Error = GetLastError();
		CloseHandle(FileHandle);
		return Error;
	}
	BOOL ReadFailed = FALSE;
	for (SIZE_T FileReadResult = 0, FileRead = 0; FileRead != FileSize;)
		if (ReadFile(FileHandle, (LPVOID)(FileData + FileRead), !ReadFailed ? (FileSize - FileRead < 0x80000000 ? (DWORD)(FileSize - FileRead) : 0x80000000) : (FileSize - FileRead < 0x10000 ? (DWORD)(FileSize - FileRead) : 0x10000), (DWORD*)&FileReadResult, 0))
			FileRead += FileReadResult;
		else if (!ReadFailed)
			ReadFailed = TRUE;
		else
		{
			Error = GetLastError();
			if (Heap)
				HeapFree(Heap, 0, (LPVOID)FileData);
			else
				VirtualFree((LPVOID)FileData, 0, MEM_RELEASE);
			CloseHandle(FileHandle);
			return Error;
		}
	CloseHandle(FileHandle);
	*Size = FileSize;
	*Data = (LPVOID)FileData;
	return 0;
}

DWORD snwuStoreFile(const WCHAR* FileName, SIZE_T Size, const LPVOID Data)
{
	HANDLE Heap = GetProcessHeap();
	if (!Heap)
		return GetLastError();
	SIZE_T DirectoryNameAndSlashSize = (SIZE_T)lstrlenW(FileName) * sizeof(WCHAR);
	while (DirectoryNameAndSlashSize && *(const WCHAR*)((UINT_PTR)FileName + DirectoryNameAndSlashSize - sizeof(WCHAR)) != L'\\' && *(const WCHAR*)((UINT_PTR)FileName + DirectoryNameAndSlashSize - sizeof(WCHAR)) != L'/')
		DirectoryNameAndSlashSize -= sizeof(WCHAR);
	WCHAR* NewTemporalFile = (WCHAR*)HeapAlloc(Heap, 0, 2 * (DirectoryNameAndSlashSize + (13 * sizeof(WCHAR))));
	if (!NewTemporalFile)
		return GetLastError();
	snwuCopy(FileName, NewTemporalFile, DirectoryNameAndSlashSize);
	HANDLE Handle;
	*(WCHAR*)((UINT_PTR)NewTemporalFile + DirectoryNameAndSlashSize) = 0;
	DWORD Error = snwuCreateFileWithRandomName(&Handle, GENERIC_WRITE, 0, FALSE, FALSE, NewTemporalFile, L".tmp");
	if (Error)
		return Error;
	HMODULE Kernel32 = GetModuleHandleW(L"Kernel32.dll");
	BOOL (WINAPI* SetFileInformationByHandleProc)(HANDLE hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, LPVOID lpFileInformation, DWORD dwBufferSize) = Kernel32 ? (BOOL(WINAPI*)(HANDLE, FILE_INFO_BY_HANDLE_CLASS, LPVOID, DWORD))GetProcAddress(Kernel32, "SetFileInformationByHandle") : 0;
#ifdef _WIN64
	if (SetFileInformationByHandleProc)
	{
		ULONGLONG FileAllocationInfoData;
		union
		{
			ULARGE_INTEGER AlignmentType;
			ULONG Data[7];
		} FileStorageInfoData;
		BOOL (WINAPI* GetFileInformationByHandleExProc)(HANDLE hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, LPVOID lpFileInformation, DWORD dwBufferSize) = (BOOL(WINAPI*)(HANDLE, FILE_INFO_BY_HANDLE_CLASS, LPVOID, DWORD))GetProcAddress(Kernel32, "GetFileInformationByHandleEx");
		if (GetFileInformationByHandleExProc && GetFileInformationByHandleExProc(Handle, (FILE_INFO_BY_HANDLE_CLASS)16, &FileStorageInfoData, (7 * sizeof(ULONG))))
			FileAllocationInfoData = (ULONGLONG)FileStorageInfoData.Data[0];
		else
			FileAllocationInfoData = 0x10000;
		FileAllocationInfoData = (ULONGLONG)Size <= (((ULONGLONG)Size + (FileAllocationInfoData - 1)) & ~(FileAllocationInfoData - 1)) ? (((ULONGLONG)Size + (FileAllocationInfoData - 1)) & ~(FileAllocationInfoData - 1)) : (ULONGLONG)Size;
		if (!SetFileInformationByHandleProc(Handle, (FILE_INFO_BY_HANDLE_CLASS)5, &FileAllocationInfoData, sizeof(ULARGE_INTEGER)))
			SetFileInformationByHandleProc = 0;
	}
	if (!SetFileInformationByHandleProc)
	{
		ULONGLONG FileEnd = (ULONGLONG)Size;
		ULONGLONG FileBegin = 0;
		if (!SetFilePointerEx(Handle, *(LARGE_INTEGER*)&FileEnd, 0, FILE_BEGIN) || !SetEndOfFile(Handle) || !SetFilePointerEx(Handle, *(LARGE_INTEGER*)&FileBegin, 0, FILE_BEGIN))
		{
			DWORD Error = GetLastError();
			CloseHandle(Handle);
			DeleteFileW(NewTemporalFile);
			HeapFree(Heap, 0, NewTemporalFile);
			return Error;
		}
	}
#else
	if (SetFileInformationByHandleProc)
	{
		ULARGE_INTEGER FileAllocationInfoData;
		union
		{
			ULARGE_INTEGER AlignmentType;
			ULONG Data[7];
		} FileStorageInfoData;
		BOOL(WINAPI* GetFileInformationByHandleExProc)(HANDLE hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, LPVOID lpFileInformation, DWORD dwBufferSize) = (BOOL(WINAPI*)(HANDLE, FILE_INFO_BY_HANDLE_CLASS, LPVOID, DWORD))GetProcAddress(Kernel32, "GetFileInformationByHandleEx");
		if (GetFileInformationByHandleExProc && GetFileInformationByHandleExProc(Handle, (FILE_INFO_BY_HANDLE_CLASS)16, &FileStorageInfoData, (7 * sizeof(ULONG))))
		{
			FileAllocationInfoData.LowPart = (DWORD)FileStorageInfoData.Data[0];
			FileAllocationInfoData.HighPart = 0;
		}
		else
		{
			FileAllocationInfoData.LowPart = 0x10000;
			FileAllocationInfoData.HighPart = 0;
		}
		FileAllocationInfoData.LowPart = (DWORD)Size <= (((DWORD)Size + (FileAllocationInfoData.LowPart - 1)) & ~(FileAllocationInfoData.LowPart - 1)) ? (((DWORD)Size + (FileAllocationInfoData.LowPart - 1)) & ~(FileAllocationInfoData.LowPart - 1)) : (DWORD)Size;
		FileAllocationInfoData.HighPart = 0;
		if (!SetFileInformationByHandleProc(Handle, (FILE_INFO_BY_HANDLE_CLASS)5, &FileAllocationInfoData, sizeof(ULARGE_INTEGER)))
			SetFileInformationByHandleProc = 0;
	}
	if (!SetFileInformationByHandleProc)
	{
		ULARGE_INTEGER FileEnd;
		ULARGE_INTEGER FileBegin;
		FileEnd.LowPart = (DWORD)Size;
		FileEnd.HighPart = 0;
		FileBegin.LowPart = 0;
		FileBegin.HighPart = 0;
		if (!SetFilePointerEx(Handle, *(LARGE_INTEGER*)&FileEnd, 0, FILE_BEGIN) || !SetEndOfFile(Handle) || !SetFilePointerEx(Handle, *(LARGE_INTEGER*)&FileBegin, 0, FILE_BEGIN))
		{
			DWORD Error = GetLastError();
			CloseHandle(Handle);
			DeleteFileW(NewTemporalFile);
			HeapFree(Heap, 0, NewTemporalFile);
			return Error;
		}
	}
#endif
	BOOL ReadFailed = FALSE;
	for (SIZE_T FileWriteResult = 0, FileWritten = 0; FileWritten != Size;)
		if (WriteFile(Handle, (LPVOID)((UINT_PTR)Data + FileWritten), !ReadFailed ? (Size - FileWritten < 0x80000000 ? (DWORD)(Size - FileWritten) : 0x80000000) : (Size - FileWritten < 0x10000 ? (DWORD)(Size - FileWritten) : 0x10000), (DWORD*)&FileWriteResult, 0))
			FileWritten += (SIZE_T)FileWriteResult;
		else if (!ReadFailed)
			ReadFailed = TRUE;
		else
		{
			DWORD Error = GetLastError();
			CloseHandle(Handle);
			DeleteFileW(NewTemporalFile);
			HeapFree(Heap, 0, NewTemporalFile);
			return Error;
		}
	if (!FlushFileBuffers(Handle))
	{
		DWORD Error = GetLastError();
		CloseHandle(Handle);
		DeleteFileW(NewTemporalFile);
		HeapFree(Heap, 0, NewTemporalFile);
		return Error;
	}
	CloseHandle(Handle);
	if (!MoveFileW(NewTemporalFile, FileName))
	{
		Error = GetLastError();
		if (Error == ERROR_ALREADY_EXISTS)
		{
			WCHAR* OldTemporalFile = (WCHAR*)((UINT_PTR)NewTemporalFile + (DirectoryNameAndSlashSize + (13 * sizeof(WCHAR))));
			snwuCopy(NewTemporalFile, OldTemporalFile, DirectoryNameAndSlashSize);
			for (;;)
			{
				*(WCHAR*)((UINT_PTR)OldTemporalFile + DirectoryNameAndSlashSize) = 0;
				Error = snwuCreateFileWithRandomName(0, 0, 0, FALSE, TRUE, OldTemporalFile, L".tmp");
				if (Error)
				{
					DeleteFileW(NewTemporalFile);
					HeapFree(Heap, 0, NewTemporalFile);
					return Error;
				}
				if (MoveFileW(FileName, OldTemporalFile))
				{
					if (MoveFileW(NewTemporalFile, FileName))
					{
						DeleteFileW(OldTemporalFile);
						HeapFree(Heap, 0, NewTemporalFile);
						return 0;
					}
					else
					{
						Error = GetLastError();
						if (!MoveFileW(OldTemporalFile, FileName))
							DeleteFileW(OldTemporalFile);
						DeleteFileW(NewTemporalFile);
						HeapFree(Heap, 0, NewTemporalFile);
						return Error;
					}
				}
				else
				{
					Error = GetLastError();
					if (Error != ERROR_ALREADY_EXISTS)
					{
						DeleteFileW(NewTemporalFile);
						HeapFree(Heap, 0, NewTemporalFile);
						return Error;
					}
				}
			}
		}
		else
		{
			DeleteFileW(NewTemporalFile);
			HeapFree(Heap, 0, NewTemporalFile);
			return Error;
		}
	}
	HeapFree(Heap, 0, NewTemporalFile);
	return 0;
}

DWORD snwuStoreBitmap(const WCHAR* FileName, SIZE_T Width, SIZE_T Height, SIZE_T Stride, const DWORD* Pixels)
{
	if (Width > 0x7FFFFFFF || Height > 0x7FFFFFFF)
		return ERROR_INVALID_PARAMETER;
	if (((DWORD)Height * (DWORD)Width) / (DWORD)Height != Width || ((DWORD)Height * (DWORD)Width) & 0xC0000000 || ((DWORD)Height * (DWORD)Width) << 2 > (((DWORD)Height * (DWORD)Width) << 2) + 124)
		return ERROR_FILE_TOO_LARGE;
	HANDLE Heap = GetProcessHeap();
	if (!Heap)
		return GetLastError();
	SIZE_T DirectoryNameAndSlashSize = (SIZE_T)lstrlenW(FileName) * sizeof(WCHAR);
	while (DirectoryNameAndSlashSize && *(const WCHAR*)((UINT_PTR)FileName + DirectoryNameAndSlashSize - sizeof(WCHAR)) != L'\\' && *(const WCHAR*)((UINT_PTR)FileName + DirectoryNameAndSlashSize - sizeof(WCHAR)) != L'/')
		DirectoryNameAndSlashSize -= sizeof(WCHAR);
	WCHAR* NewTemporalFile = (WCHAR*)HeapAlloc(Heap, 0, 2 * (DirectoryNameAndSlashSize + (13 * sizeof(WCHAR))));
	if (!NewTemporalFile)
		return GetLastError();
	snwuCopy(FileName, NewTemporalFile, DirectoryNameAndSlashSize);
	HANDLE FileHandle;
	*(WCHAR*)((UINT_PTR)NewTemporalFile + DirectoryNameAndSlashSize) = 0;
	DWORD Error = snwuCreateFileWithRandomName(&FileHandle, GENERIC_READ | GENERIC_WRITE, 0, FALSE, FALSE, NewTemporalFile, L".tmp");
	ULARGE_INTEGER FileSize;
	ULARGE_INTEGER FileBegin;
	FileSize.LowPart = (DWORD)124 + (((DWORD)Height * (DWORD)Width) << 2);
	FileSize.HighPart = 0;
	FileBegin.LowPart = 0;
	FileBegin.HighPart = 0;
	if (!SetFilePointerEx(FileHandle, *(LARGE_INTEGER*)&FileSize, 0, FILE_BEGIN) || !SetEndOfFile(FileHandle) || !SetFilePointerEx(FileHandle, *(LARGE_INTEGER*)&FileBegin, 0, FILE_BEGIN))
	{
		Error = GetLastError();
		CloseHandle(FileHandle);
		DeleteFileW(NewTemporalFile);
		HeapFree(Heap, 0, NewTemporalFile);
		return Error;
	}
	HANDLE MappingHandle = CreateFileMappingW(FileHandle, 0, PAGE_READWRITE, 0, FileSize.LowPart, 0);
	if (!MappingHandle)
	{
		Error = GetLastError();
		CloseHandle(FileHandle);
		DeleteFileW(NewTemporalFile);
		HeapFree(Heap, 0, NewTemporalFile);
		return Error;
	}
	UINT_PTR FileData = (UINT_PTR)MapViewOfFile(MappingHandle, FILE_MAP_READ | FILE_MAP_WRITE, 0, 0, (SIZE_T)FileSize.LowPart);
	if (!FileData)
	{
		Error = GetLastError();
		CloseHandle(MappingHandle);
		CloseHandle(FileHandle);
		DeleteFileW(NewTemporalFile);
		HeapFree(Heap, 0, NewTemporalFile);
		return Error;
	}
	CloseHandle(MappingHandle);
	CloseHandle(FileHandle);
	*(WORD*)FileData = 0x4D42;// bmp signature
	*(WORD*)(FileData + 2) = (WORD)FileSize.LowPart;// file size low
	*(WORD*)(FileData + 4) = (WORD)(FileSize.LowPart >> 16);//  file size high
	*(WORD*)(FileData + 6) = 0;// reserved
	*(WORD*)(FileData + 8) = 0;// reserved
	*(WORD*)(FileData + 10) = 124;// pixel offset low
	*(WORD*)(FileData + 12) = 0;// pixel offset high
	*(WORD*)(FileData + 14) = 108;// DIB header size low
	*(WORD*)(FileData + 16) = 0;// DIB header size high
	*(WORD*)(FileData + 18) = (WORD)Width;// width low
	*(WORD*)(FileData + 20) = (WORD)(Width >> 16);// width low
	*(WORD*)(FileData + 22) = (WORD)Height;// height low
	*(WORD*)(FileData + 24) = (WORD)(Height >> 16);// height low
	*(WORD*)(FileData + 26) = 1;// number of color planes
	*(WORD*)(FileData + 28) = 32;// bits per pixel
	*(WORD*)(FileData + 30) = 3;//BI_BITFIELDS low
	*(WORD*)(FileData + 32) = 0;//BI_BITFIELDS high
	*(WORD*)(FileData + 34) = (WORD)(((DWORD)Height * (DWORD)Width) << 2);//size of bitmap data low
	*(WORD*)(FileData + 36) = (WORD)(((DWORD)Height * (DWORD)Width) >> 14);//size of bitmap data high
	*(WORD*)(FileData + 38) = 2835;//pixels/meter horizontal low
	*(WORD*)(FileData + 40) = 0;//pixels/meter horizontal high
	*(WORD*)(FileData + 42) = 2835;//pixels/meter vertical low
	*(WORD*)(FileData + 44) = 0;//pixels/meter vertical high
	*(WORD*)(FileData + 46) = 0;//colors in the palette low
	*(WORD*)(FileData + 48) = 0;//colors in the palette high
	*(WORD*)(FileData + 50) = 0;//important colors low (0 means all colors are important)
	*(WORD*)(FileData + 52) = 0;//important colors low (0 means all colors are important)
	*(WORD*)(FileData + 54) = 0x00FF;//red channel mask low
	*(WORD*)(FileData + 56) = 0x0000;//red channel mask high
	*(WORD*)(FileData + 58) = 0xFF00;//green channel mask low
	*(WORD*)(FileData + 60) = 0x0000;//green channel mask high
	*(WORD*)(FileData + 62) = 0x0000;//blue channel mask low
	*(WORD*)(FileData + 64) = 0x00FF;//blue channel mask high
	*(WORD*)(FileData + 66) = 0x0000;//alpha channel mask low
	*(WORD*)(FileData + 68) = 0xFF00;//alpha channel mask high
	*(WORD*)(FileData + 70) = 0x6E20;//LCS_WINDOWS_COLOR_SPACE low
	*(WORD*)(FileData + 72) = 0x5769;//LCS_WINDOWS_COLOR_SPACE high
	*(WORD*)(FileData + 74) = 0;// clear rest of the header
	for (SIZE_T Clear = 76; Clear != 124; Clear += 4)
		*(DWORD*)(FileData + Clear) = 0;
	SIZE_T RowSize = Width << 2;
	for (DWORD* Write = (DWORD*)(FileData + 124), *SourceRow = (DWORD*)Pixels, *EndSourceRow = (DWORD*)((UINT_PTR)SourceRow + (Height * Stride)); SourceRow != EndSourceRow; SourceRow = (DWORD*)((UINT_PTR)SourceRow + Stride))
		for (DWORD* Read = SourceRow, *EndRead = (DWORD*)((UINT_PTR)Read + RowSize); Read != EndRead;)
			*Write++ = *Read++;
	if (!FlushViewOfFile((LPVOID)FileData, (SIZE_T)FileSize.LowPart))
	{
		Error = GetLastError();
		UnmapViewOfFile((LPVOID)FileData);
		DeleteFileW(NewTemporalFile);
		HeapFree(Heap, 0, NewTemporalFile);
		return Error;
	}
	UnmapViewOfFile((LPVOID)FileData);
	if (!MoveFileW(NewTemporalFile, FileName))
	{
		Error = GetLastError();
		if (Error == ERROR_ALREADY_EXISTS)
		{
			WCHAR* OldTemporalFile = (WCHAR*)((UINT_PTR)NewTemporalFile + (DirectoryNameAndSlashSize + (13 * sizeof(WCHAR))));
			snwuCopy(NewTemporalFile, OldTemporalFile, DirectoryNameAndSlashSize);
			for (;;)
			{
				*(WCHAR*)((UINT_PTR)OldTemporalFile + DirectoryNameAndSlashSize) = 0;
				Error = snwuCreateFileWithRandomName(0, 0, 0, FALSE, TRUE, OldTemporalFile, L".tmp");
				if (Error)
				{
					DeleteFileW(NewTemporalFile);
					HeapFree(Heap, 0, NewTemporalFile);
					return Error;
				}
				if (MoveFileW(FileName, OldTemporalFile))
				{
					if (MoveFileW(NewTemporalFile, FileName))
					{
						DeleteFileW(OldTemporalFile);
						HeapFree(Heap, 0, NewTemporalFile);
						return 0;
					}
					else
					{
						Error = GetLastError();
						if (!MoveFileW(OldTemporalFile, FileName))
							DeleteFileW(OldTemporalFile);
						DeleteFileW(NewTemporalFile);
						HeapFree(Heap, 0, NewTemporalFile);
						return Error;
					}
				}
				else
				{
					Error = GetLastError();
					if (Error != ERROR_ALREADY_EXISTS)
					{
						DeleteFileW(NewTemporalFile);
						HeapFree(Heap, 0, NewTemporalFile);
						return Error;
					}
				}
			}
		}
		else
		{
			DeleteFileW(NewTemporalFile);
			HeapFree(Heap, 0, NewTemporalFile);
			return Error;
		}
	}
	HeapFree(Heap, 0, NewTemporalFile);
	return 0;
}

void snwuDrawTestImage(SIZE_T Width, SIZE_T Height, SIZE_T Stride, DWORD* Pixels)
{
	for (SIZE_T RowIncroment = Stride - (Width << 2), Y = 0; Y != Height; Pixels = (DWORD*)((UINT_PTR)Pixels + RowIncroment), ++Y)
	{
		DWORD RowBaseColor = ((((Y << 16) / Height) << 8) & 0x00FF0000) | 0xFF000000;
		for (SIZE_T X = 0; X != Width; ++X)
			*Pixels++ = RowBaseColor | ((((X << 16) / Width) >> 8) & 0x000000FF);
	}
}

DWORD snwuCreateFilePath(SIZE_T PathBufferSize, WCHAR* PathBuffer, const WCHAR* Directory, const WCHAR* File, SIZE_T* PathSize)
{
	if ((UINT_PTR)File > 1 && !*File)
		File = 0;
	HANDLE Heap = GetProcessHeap();
	if (!Heap)
		return GetLastError();
	SIZE_T TemporalPathBufferCapasity = (MAX_PATH + 1) * sizeof(WCHAR);
	WCHAR* TemporalPathBuffer;
	DWORD Error = _snwuInternalHeapAlloc(Heap, (LPVOID*)&TemporalPathBuffer, &TemporalPathBufferCapasity);
	if (Error)
		return Error;
	SIZE_T TemporalPathBufferSize = 0;
	HMODULE Ole32 = 0;
	void (WINAPI* Ole32_CoTaskMemFree)(LPVOID pv) = 0;
	HMODULE Shell32 = 0;
	BOOL (WINAPI* Shell32_SHGetSpecialFolderPathW)(HWND hwndOwner, LPTSTR lpszPath, int csidl, BOOL fCreate) = 0;
	HRESULT (WINAPI* Shell32_SHGetKnownFolderPath)(VOID* rfid, DWORD dwFlags, HANDLE hToken, PWSTR *ppszPath) = 0;
	HMODULE Userenv = 0;
	BOOL (WINAPI* Userenv_GetUserProfileDirectoryW)(HANDLE hToken, LPWSTR lpProfileDir, LPDWORD lpcchSize) = 0;
	HMODULE CurrentModule = 0;
	HANDLE CurrentProcessToken = 0;
	Error = ERROR_INSUFFICIENT_BUFFER;
	while (Error)
	{
		switch ((UINT_PTR)Directory)
		{
			case (UINT_PTR)SNWU_DIRECTORY_EXECUTABLE :
			{
				TemporalPathBufferSize = (SIZE_T)GetModuleFileNameW(0, TemporalPathBuffer, (TemporalPathBufferCapasity / sizeof(WCHAR)) < 0xFFFFFFFF ? (DWORD)(TemporalPathBufferCapasity / sizeof(WCHAR)) : 0xFFFFFFFF) * sizeof(WCHAR);
				if (TemporalPathBufferSize)
				{
					if (TemporalPathBufferSize < TemporalPathBufferCapasity)
					{
						TemporalPathBufferSize = (File ? _snwuInternalCutLastComponentFromPathAndLeaveSlash(TemporalPathBuffer) : _snwuInternalCutSlashAndLastComponentFromPath(TemporalPathBuffer)) + sizeof(WCHAR);
						Error = 0;
					}
					else
						Error = ERROR_INSUFFICIENT_BUFFER;
				}
				else
					Error = GetLastError();
				break;
			}
			case (UINT_PTR)SNWU_DIRECTORY_MODULE :
			{
				if (CurrentModule || GetModuleHandleExW(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT, (WCHAR*)snwuCreateFilePath, &CurrentModule))
				{
					TemporalPathBufferSize = (SIZE_T)GetModuleFileNameW(CurrentModule, TemporalPathBuffer, (TemporalPathBufferCapasity / sizeof(WCHAR)) < 0xFFFFFFFF ? (DWORD)(TemporalPathBufferCapasity / sizeof(WCHAR)) : 0xFFFFFFFF) * sizeof(WCHAR);
					if (TemporalPathBufferSize)
					{
						if (TemporalPathBufferSize < TemporalPathBufferCapasity)
						{
							TemporalPathBufferSize = (File ? _snwuInternalCutLastComponentFromPathAndLeaveSlash(TemporalPathBuffer) : _snwuInternalCutSlashAndLastComponentFromPath(TemporalPathBuffer)) + sizeof(WCHAR);
							Error = 0;
						}
						else
							Error = ERROR_INSUFFICIENT_BUFFER;
					}
					else
						Error = GetLastError();
				}
				else
					Error = GetLastError();
				break;
			}
			case (UINT_PTR)SNWU_DIRECTORY_TEMPORAL :
			{
				TemporalPathBufferSize = (SIZE_T)GetEnvironmentVariableW(L"TMP", TemporalPathBuffer, ((TemporalPathBufferCapasity - sizeof(WCHAR)) / sizeof(WCHAR)) < 0xFFFFFFFF ? (DWORD)((TemporalPathBufferCapasity - sizeof(WCHAR)) / sizeof(WCHAR)) : 0xFFFFFFFF) * sizeof(WCHAR);
				if (TemporalPathBufferSize)
				{
					TemporalPathBufferSize += sizeof(WCHAR);
					if (TemporalPathBufferCapasity < TemporalPathBufferSize)
						Error = ERROR_INSUFFICIENT_BUFFER;
					else
					{
						if (File && *(WCHAR*)((UINT_PTR)TemporalPathBuffer + TemporalPathBufferSize - (2 * sizeof(WCHAR))) != L'\\')
						{
							*(WCHAR*)((UINT_PTR)TemporalPathBuffer + TemporalPathBufferSize - sizeof(WCHAR)) = L'\\';
							*(WCHAR*)((UINT_PTR)TemporalPathBuffer + TemporalPathBufferSize) = 0;
							TemporalPathBufferSize += sizeof(WCHAR);
						}
						Error = 0;
					}
					break;
				}
				TemporalPathBufferSize = (SIZE_T)GetEnvironmentVariableW(L"TEMP", TemporalPathBuffer, ((TemporalPathBufferCapasity - sizeof(WCHAR)) / sizeof(WCHAR)) < 0xFFFFFFFF ? (DWORD)((TemporalPathBufferCapasity - sizeof(WCHAR)) / sizeof(WCHAR)) : 0xFFFFFFFF) * sizeof(WCHAR);
				if (TemporalPathBufferSize)
				{
					TemporalPathBufferSize += sizeof(WCHAR);
					if (TemporalPathBufferCapasity < TemporalPathBufferSize)
						Error = ERROR_INSUFFICIENT_BUFFER;
					else
					{
						if (File && *(WCHAR*)((UINT_PTR)TemporalPathBuffer + TemporalPathBufferSize - (2 * sizeof(WCHAR))) != L'\\')
						{
							*(WCHAR*)((UINT_PTR)TemporalPathBuffer + TemporalPathBufferSize - sizeof(WCHAR)) = L'\\';
							*(WCHAR*)((UINT_PTR)TemporalPathBuffer + TemporalPathBufferSize) = 0;
							TemporalPathBufferSize += sizeof(WCHAR);
						}
						Error = 0;
					}
					break;
				}
				if (!TemporalPathBufferSize)
				{
					TemporalPathBufferSize = (SIZE_T)GetModuleFileNameW(0, TemporalPathBuffer, (TemporalPathBufferCapasity / sizeof(WCHAR)) < 0xFFFFFFFF ? (DWORD)(TemporalPathBufferCapasity / sizeof(WCHAR)) : 0xFFFFFFFF) * sizeof(WCHAR);
					if (TemporalPathBufferSize)
					{
						if (TemporalPathBufferSize < TemporalPathBufferCapasity)
						{
							TemporalPathBufferSize = (File ? _snwuInternalCutLastComponentFromPathAndLeaveSlash(TemporalPathBuffer) : _snwuInternalCutSlashAndLastComponentFromPath(TemporalPathBuffer)) + sizeof(WCHAR);
							Error = 0;
						}
						else
							Error = ERROR_INSUFFICIENT_BUFFER;
					}
					else
						Error = GetLastError();
				}
				break;
			}
			case (UINT_PTR)SNWU_DIRECTORY_SYSTEM :
			{
				TemporalPathBufferSize = (SIZE_T)GetSystemDirectoryW(TemporalPathBuffer, ((TemporalPathBufferCapasity - sizeof(WCHAR)) / sizeof(WCHAR)) < 0xFFFFFFFF ? (DWORD)((TemporalPathBufferCapasity - sizeof(WCHAR)) / sizeof(WCHAR)) : 0xFFFFFFFF) * sizeof(WCHAR);
				if (!TemporalPathBufferSize)
					Error = GetLastError();
				else
				{
					TemporalPathBufferSize += sizeof(WCHAR);
					if (TemporalPathBufferSize < TemporalPathBufferCapasity)
					{
						if (File && *(WCHAR*)((UINT_PTR)TemporalPathBuffer + TemporalPathBufferSize - (2 * sizeof(WCHAR))) != L'\\')
						{
							*(WCHAR*)((UINT_PTR)TemporalPathBuffer + TemporalPathBufferSize - sizeof(WCHAR)) = L'\\';
							*(WCHAR*)((UINT_PTR)TemporalPathBuffer + TemporalPathBufferSize) = 0;
							TemporalPathBufferSize += sizeof(WCHAR);
						}
						Error = 0;
					}
					else
						Error = ERROR_INSUFFICIENT_BUFFER;
				}
				break;
			}
			case (UINT_PTR)SNWU_DIRECTORY_FONTS :
			{
				if (!Ole32)
				{
					Ole32 = LoadLibraryW(L"Ole32.dll");
					if (Ole32)
						Ole32_CoTaskMemFree = (void (WINAPI*)(LPVOID))GetProcAddress(Ole32, "CoTaskMemFree");
				}
				if (!Shell32)
				{
					Shell32 = LoadLibraryW(L"Shell32.dll");
					if (Shell32)
					{
						Shell32_SHGetSpecialFolderPathW = (BOOL (WINAPI*)(HWND, LPTSTR, int, BOOL))GetProcAddress(Shell32, "SHGetSpecialFolderPathW");
						Shell32_SHGetKnownFolderPath = (HRESULT (WINAPI*)(VOID*, DWORD, HANDLE, PWSTR*))GetProcAddress(Shell32, "SHGetKnownFolderPath");
					}
				}
				if (Shell32_SHGetKnownFolderPath && Ole32_CoTaskMemFree)
				{
					WCHAR* FontPath = 0;
					const DWORD FontFolderGUID[4] = { 0xFD228CB7, 0x4AE3AE11, 0xF3164C86, 0xFEB80A91 };//FOLDERID_Fonts (0xFD228CB7, 0xAE11, 0x4AE3, 0x86, 0x4C, 0x16, 0xF3, 0x91, 0x0A, 0xB8, 0xFE)
					Error = (DWORD)Shell32_SHGetKnownFolderPath((VOID*)FontFolderGUID, 0, 0, &FontPath);
					if (!Error)
					{
						TemporalPathBufferSize = snwuStringSize(FontPath);
						if (File)
						{
							if (TemporalPathBufferSize < TemporalPathBufferCapasity - sizeof(WCHAR))
							{
								snwuCopy(FontPath, TemporalPathBuffer, TemporalPathBufferSize);
								if (*(WCHAR*)((UINT_PTR)TemporalPathBuffer + TemporalPathBufferSize - (2 * sizeof(WCHAR))) != L'\\')
								{
									*(WCHAR*)((UINT_PTR)TemporalPathBuffer + TemporalPathBufferSize - sizeof(WCHAR)) = L'\\';
									*(WCHAR*)((UINT_PTR)TemporalPathBuffer + TemporalPathBufferSize) = 0;
									TemporalPathBufferSize += sizeof(WCHAR);
								}
								Error = 0;
							}
							else
								Error = ERROR_INSUFFICIENT_BUFFER;
						}
						else
						{
							if (TemporalPathBufferSize < TemporalPathBufferCapasity)
							{
								snwuCopy(FontPath, TemporalPathBuffer, TemporalPathBufferSize);
								Error = 0;
							}
							else
								Error = ERROR_INSUFFICIENT_BUFFER;
						}
						Ole32_CoTaskMemFree(FontPath);
					}
				}
				else
					Error = ERROR_NOT_SUPPORTED;
				if (Error)
					if (Shell32_SHGetSpecialFolderPathW)
					{
						if (TemporalPathBufferCapasity < ((MAX_PATH + 1) * sizeof(WCHAR)))
						{
							TemporalPathBufferSize = ((MAX_PATH + 1) * sizeof(WCHAR));
							Error = ERROR_INSUFFICIENT_BUFFER;
						}
						else
						{
							if (Shell32_SHGetSpecialFolderPathW(0, TemporalPathBuffer, 0x0014, FALSE))
							{
								TemporalPathBufferSize = snwuStringSize(TemporalPathBuffer);
								if (File)
								{
									if (TemporalPathBufferSize < TemporalPathBufferCapasity - sizeof(WCHAR))
									{
										if (*(WCHAR*)((UINT_PTR)TemporalPathBuffer + TemporalPathBufferSize - (2 * sizeof(WCHAR))) != L'\\')
										{
											*(WCHAR*)((UINT_PTR)TemporalPathBuffer + TemporalPathBufferSize - sizeof(WCHAR)) = L'\\';
											*(WCHAR*)((UINT_PTR)TemporalPathBuffer + TemporalPathBufferSize) = 0;
											TemporalPathBufferSize += sizeof(WCHAR);
										}
										Error = 0;
									}
									else
										Error = ERROR_INSUFFICIENT_BUFFER;
								}
								else
									Error = 0;
							}
							else
							{
								Error = GetLastError();
								if (!Error)
									Error = ERROR_NOT_SUPPORTED;
							}
						}
					}
					else
						Error = ERROR_NOT_SUPPORTED;
				break;
			}
			case (UINT_PTR)SNWU_DIRECTORY_USER :
			{
				if (CurrentProcessToken || OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &CurrentProcessToken))
				{
					if (!Userenv)
					{
						Userenv = LoadLibraryW(L"Userenv.dll");
						if (Userenv)
							Userenv_GetUserProfileDirectoryW = (BOOL (WINAPI*)(HANDLE, LPWSTR, LPDWORD))GetProcAddress(Userenv, "GetUserProfileDirectoryW");
					}
					if (Userenv_GetUserProfileDirectoryW)
					{
						DWORD Length = 0;
						Userenv_GetUserProfileDirectoryW(CurrentProcessToken, 0, &Length);
						if (Length)
						{
							if (File)
							{
								if ((SIZE_T)Length * sizeof(WCHAR) < TemporalPathBufferCapasity - sizeof(WCHAR))
								{
									if (Userenv_GetUserProfileDirectoryW(CurrentProcessToken, TemporalPathBuffer, &Length))
									{
										TemporalPathBufferSize = (SIZE_T)Length * sizeof(WCHAR);
										if (*(WCHAR*)((UINT_PTR)TemporalPathBuffer + TemporalPathBufferSize - (2 * sizeof(WCHAR))) != L'\\')
										{
											*(WCHAR*)((UINT_PTR)TemporalPathBuffer + TemporalPathBufferSize - sizeof(WCHAR)) = L'\\';
											*(WCHAR*)((UINT_PTR)TemporalPathBuffer + TemporalPathBufferSize) = 0;
											TemporalPathBufferSize += sizeof(WCHAR);
										}
										Error = 0;
									}
									else
										Error = GetLastError();
								}
								else
								{
									TemporalPathBufferSize = (SIZE_T)Length * sizeof(WCHAR) + sizeof(WCHAR);
									Error = ERROR_INSUFFICIENT_BUFFER;
								}
							}
							else
							{
								if ((SIZE_T)Length * sizeof(WCHAR) < TemporalPathBufferCapasity)
								{
									if (Userenv_GetUserProfileDirectoryW(CurrentProcessToken, TemporalPathBuffer, &Length))
									{
										TemporalPathBufferSize = (SIZE_T)Length * sizeof(WCHAR);
										Error = 0;
									}
									else
										Error = GetLastError();
								}
								else
								{
									TemporalPathBufferSize = (SIZE_T)Length * sizeof(WCHAR);
									Error = ERROR_INSUFFICIENT_BUFFER;
								}
							}
						}
						else
							Error = GetLastError();
					}
					else
						Error = GetLastError();
				}
				else
					Error = GetLastError();
				break;
			}
			case (UINT_PTR)SNWU_DIRECTORY_DATA :
			{
				TemporalPathBufferSize = (SIZE_T)GetEnvironmentVariableW(L"APPDATA", TemporalPathBuffer, ((TemporalPathBufferCapasity - sizeof(WCHAR)) / sizeof(WCHAR)) < 0xFFFFFFFF ? (DWORD)((TemporalPathBufferCapasity - sizeof(WCHAR)) / sizeof(WCHAR)) : 0xFFFFFFFF) * sizeof(WCHAR);
				if (TemporalPathBufferSize)
				{
					TemporalPathBufferSize += sizeof(WCHAR);
					if (TemporalPathBufferCapasity < TemporalPathBufferSize)
						Error = ERROR_INSUFFICIENT_BUFFER;
					else
					{
						if (File && *(WCHAR*)((UINT_PTR)TemporalPathBuffer + TemporalPathBufferSize - (2 * sizeof(WCHAR))) != L'\\')
						{
							*(WCHAR*)((UINT_PTR)TemporalPathBuffer + TemporalPathBufferSize - sizeof(WCHAR)) = L'\\';
							*(WCHAR*)((UINT_PTR)TemporalPathBuffer + TemporalPathBufferSize) = 0;
							TemporalPathBufferSize += sizeof(WCHAR);
						}
						Error = 0;
					}
					break;
				}
				if (CurrentProcessToken || OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &CurrentProcessToken))
				{
					if (!Userenv)
					{
						Userenv = LoadLibraryW(L"Userenv.dll");
						if (Userenv)
							Userenv_GetUserProfileDirectoryW = (BOOL(WINAPI*)(HANDLE, LPWSTR, LPDWORD))GetProcAddress(Userenv, "GetUserProfileDirectoryW");
					}
					if (Userenv_GetUserProfileDirectoryW)
					{
						DWORD Length = 0;
						Userenv_GetUserProfileDirectoryW(CurrentProcessToken, 0, &Length);
						if (Length)
						{
							if (File)
							{
								if ((SIZE_T)Length * sizeof(WCHAR) < TemporalPathBufferCapasity - sizeof(WCHAR))
								{
									if (Userenv_GetUserProfileDirectoryW(CurrentProcessToken, TemporalPathBuffer, &Length))
									{
										TemporalPathBufferSize = (SIZE_T)Length * sizeof(WCHAR);
										if (*(WCHAR*)((UINT_PTR)TemporalPathBuffer + TemporalPathBufferSize - (2 * sizeof(WCHAR))) != L'\\')
										{
											*(WCHAR*)((UINT_PTR)TemporalPathBuffer + TemporalPathBufferSize - sizeof(WCHAR)) = L'\\';
											*(WCHAR*)((UINT_PTR)TemporalPathBuffer + TemporalPathBufferSize) = 0;
											TemporalPathBufferSize += sizeof(WCHAR);
										}
										Error = 0;
									}
									else
										Error = GetLastError();
								}
								else
								{
									TemporalPathBufferSize = (SIZE_T)Length * sizeof(WCHAR) + sizeof(WCHAR);
									Error = ERROR_INSUFFICIENT_BUFFER;
								}
							}
							else
							{
								if ((SIZE_T)Length * sizeof(WCHAR) < TemporalPathBufferCapasity)
								{
									if (Userenv_GetUserProfileDirectoryW(CurrentProcessToken, TemporalPathBuffer, &Length))
									{
										TemporalPathBufferSize = (SIZE_T)Length * sizeof(WCHAR);
										Error = 0;
									}
									else
										Error = GetLastError();
								}
								else
								{
									TemporalPathBufferSize = (SIZE_T)Length * sizeof(WCHAR);
									Error = ERROR_INSUFFICIENT_BUFFER;
								}
							}
						}
						else
							Error = GetLastError();
					}
					else
						Error = GetLastError();
				}
				else
					Error = GetLastError();
				break;
			}
			case (UINT_PTR)SNWU_DIRECTORY_DESKTOP :
			{
				if (!Ole32)
				{
					Ole32 = LoadLibraryW(L"Ole32.dll");
					if (Ole32)
						Ole32_CoTaskMemFree = (void (WINAPI*)(LPVOID))GetProcAddress(Ole32, "CoTaskMemFree");
				}
				if (!Shell32)
				{
					Shell32 = LoadLibraryW(L"Shell32.dll");
					if (Shell32)
					{
						Shell32_SHGetSpecialFolderPathW = (BOOL(WINAPI*)(HWND, LPTSTR, int, BOOL))GetProcAddress(Shell32, "SHGetSpecialFolderPathW");
						Shell32_SHGetKnownFolderPath = (HRESULT(WINAPI*)(VOID*, DWORD, HANDLE, PWSTR*))GetProcAddress(Shell32, "SHGetKnownFolderPath");
					}
				}
				if (Shell32_SHGetKnownFolderPath && Ole32_CoTaskMemFree)
				{
					WCHAR* DesktopPath = 0;
					const DWORD DesktopFolderGUID[4] = { 0xB4BFCC3A, 0x424CDB2C, 0xE97F29B0, 0x41C6879A };// FOLDERID_Desktop (0xB4BFCC3A, 0xDB2C, 0x424C, 0xB0, 0x29, 0x7F, 0xE9, 0x9A, 0x87, 0xC6, 0x41)
					Error = (DWORD)Shell32_SHGetKnownFolderPath((VOID*)DesktopFolderGUID, 0, 0, &DesktopPath);
					if (!Error)
					{
						TemporalPathBufferSize = snwuStringSize(DesktopPath);
						if (File)
						{
							if (TemporalPathBufferSize < TemporalPathBufferCapasity - sizeof(WCHAR))
							{
								snwuCopy(DesktopPath, TemporalPathBuffer, TemporalPathBufferSize);
								if (*(WCHAR*)((UINT_PTR)TemporalPathBuffer + TemporalPathBufferSize - (2 * sizeof(WCHAR))) != L'\\')
								{
									*(WCHAR*)((UINT_PTR)TemporalPathBuffer + TemporalPathBufferSize - sizeof(WCHAR)) = L'\\';
									*(WCHAR*)((UINT_PTR)TemporalPathBuffer + TemporalPathBufferSize) = 0;
									TemporalPathBufferSize += sizeof(WCHAR);
								}
								Error = 0;
							}
							else
								Error = ERROR_INSUFFICIENT_BUFFER;
						}
						else
						{
							if (TemporalPathBufferSize < TemporalPathBufferCapasity)
							{
								snwuCopy(DesktopPath, TemporalPathBuffer, TemporalPathBufferSize);
								Error = 0;
							}
							else
								Error = ERROR_INSUFFICIENT_BUFFER;
						}
						Ole32_CoTaskMemFree(DesktopPath);
					}
				}
				else
					Error = ERROR_NOT_SUPPORTED;
				if (Error)
					if (Shell32_SHGetSpecialFolderPathW)
					{
						if (TemporalPathBufferCapasity < ((MAX_PATH + 1) * sizeof(WCHAR)))
						{
							TemporalPathBufferSize = ((MAX_PATH + 1) * sizeof(WCHAR));
							Error = ERROR_INSUFFICIENT_BUFFER;
						}
						else
						{
							if (Shell32_SHGetSpecialFolderPathW(0, TemporalPathBuffer, 0x0010, FALSE))
							{
								TemporalPathBufferSize = snwuStringSize(TemporalPathBuffer);
								if (File)
								{
									if (TemporalPathBufferSize < TemporalPathBufferCapasity - sizeof(WCHAR))
									{
										if (*(WCHAR*)((UINT_PTR)TemporalPathBuffer + TemporalPathBufferSize - (2 * sizeof(WCHAR))) != L'\\')
										{
											*(WCHAR*)((UINT_PTR)TemporalPathBuffer + TemporalPathBufferSize - sizeof(WCHAR)) = L'\\';
											*(WCHAR*)((UINT_PTR)TemporalPathBuffer + TemporalPathBufferSize) = 0;
											TemporalPathBufferSize += sizeof(WCHAR);
										}
										Error = 0;
									}
									else
										Error = ERROR_INSUFFICIENT_BUFFER;
								}
								else
									Error = 0;
							}
							else
							{
								Error = GetLastError();
								if (!Error)
									Error = ERROR_NOT_SUPPORTED;
							}
						}
					}
					else
						Error = ERROR_NOT_SUPPORTED;
				break;
			}
			case (UINT_PTR)SNWU_DIRECTORY_CURRENT:
			{
				TemporalPathBufferSize = (SIZE_T)GetCurrentDirectoryW((TemporalPathBufferCapasity - sizeof(WCHAR)) / sizeof(WCHAR) < 0xFFFFFFFF ? (DWORD)((TemporalPathBufferCapasity - sizeof(WCHAR)) / sizeof(WCHAR)) : 0xFFFFFFFF, TemporalPathBuffer) * sizeof(WCHAR);
				if (!TemporalPathBufferSize)
					Error = GetLastError();
				else
				{
					if (File)
					{
						if (TemporalPathBufferSize < TemporalPathBufferCapasity - sizeof(WCHAR))
						{
							TemporalPathBufferSize += sizeof(WCHAR);
							if (*(WCHAR*)((UINT_PTR)TemporalPathBuffer + TemporalPathBufferSize - (2 * sizeof(WCHAR))) != L'\\')
							{
								*(WCHAR*)((UINT_PTR)TemporalPathBuffer + TemporalPathBufferSize - sizeof(WCHAR)) = L'\\';
								*(WCHAR*)((UINT_PTR)TemporalPathBuffer + TemporalPathBufferSize) = 0;
								TemporalPathBufferSize += sizeof(WCHAR);
							}
							Error = 0;
						}
						else
							Error = ERROR_INSUFFICIENT_BUFFER;
					}
					else
					{
						if (TemporalPathBufferSize < TemporalPathBufferCapasity)
							Error = 0;
						else
							Error = ERROR_INSUFFICIENT_BUFFER;
					}
				}
				break;
			}
			case (UINT_PTR)SNWU_DIRECTORY_DOCUMENTS :
			{
				if (!Ole32)
				{
					Ole32 = LoadLibraryW(L"Ole32.dll");
					if (Ole32)
						Ole32_CoTaskMemFree = (void (WINAPI*)(LPVOID))GetProcAddress(Ole32, "CoTaskMemFree");
				}
				if (!Shell32)
				{
					Shell32 = LoadLibraryW(L"Shell32.dll");
					if (Shell32)
					{
						Shell32_SHGetSpecialFolderPathW = (BOOL(WINAPI*)(HWND, LPTSTR, int, BOOL))GetProcAddress(Shell32, "SHGetSpecialFolderPathW");
						Shell32_SHGetKnownFolderPath = (HRESULT(WINAPI*)(VOID*, DWORD, HANDLE, PWSTR*))GetProcAddress(Shell32, "SHGetKnownFolderPath");
					}
				}
				if (Shell32_SHGetKnownFolderPath && Ole32_CoTaskMemFree)
				{
					WCHAR* DocumentPath = 0;
					const DWORD DocumentFolderGUID[4] = { 0xFDD39AD0, 0x46AF238F, 0x856CB4AD, 0xC7690348 };// FOLDERID_Documents (0xFDD39AD0, 0x238F, 0x46AF, 0xAD, 0xB4, 0x6C, 0x85, 0x48, 0x03, 0x69, 0xC7)
					Error = (DWORD)Shell32_SHGetKnownFolderPath((VOID*)DocumentFolderGUID, 0, 0, &DocumentPath);
					if (!Error)
					{
						TemporalPathBufferSize = snwuStringSize(DocumentPath);
						if (File)
						{
							if (TemporalPathBufferSize < TemporalPathBufferCapasity - sizeof(WCHAR))
							{
								snwuCopy(DocumentPath, TemporalPathBuffer, TemporalPathBufferSize);
								if (*(WCHAR*)((UINT_PTR)TemporalPathBuffer + TemporalPathBufferSize - (2 * sizeof(WCHAR))) != L'\\')
								{
									*(WCHAR*)((UINT_PTR)TemporalPathBuffer + TemporalPathBufferSize - sizeof(WCHAR)) = L'\\';
									*(WCHAR*)((UINT_PTR)TemporalPathBuffer + TemporalPathBufferSize) = 0;
									TemporalPathBufferSize += sizeof(WCHAR);
								}
								Error = 0;
							}
							else
								Error = ERROR_INSUFFICIENT_BUFFER;
						}
						else
						{
							if (TemporalPathBufferSize < TemporalPathBufferCapasity)
							{
								snwuCopy(DocumentPath, TemporalPathBuffer, TemporalPathBufferSize);
								Error = 0;
							}
							else
								Error = ERROR_INSUFFICIENT_BUFFER;
						}
						Ole32_CoTaskMemFree(DocumentPath);
					}
				}
				else
					Error = ERROR_NOT_SUPPORTED;
				if (Error)
					if (Shell32_SHGetSpecialFolderPathW)
					{
						if (TemporalPathBufferCapasity < ((MAX_PATH + 1) * sizeof(WCHAR)))
						{
							TemporalPathBufferSize = ((MAX_PATH + 1) * sizeof(WCHAR));
							Error = ERROR_INSUFFICIENT_BUFFER;
						}
						else
						{
							if (Shell32_SHGetSpecialFolderPathW(0, TemporalPathBuffer, 0x0005, FALSE))
							{
								TemporalPathBufferSize = snwuStringSize(TemporalPathBuffer);
								if (File)
								{
									if (TemporalPathBufferSize < TemporalPathBufferCapasity - sizeof(WCHAR))
									{
										if (*(WCHAR*)((UINT_PTR)TemporalPathBuffer + TemporalPathBufferSize - (2 * sizeof(WCHAR))) != L'\\')
										{
											*(WCHAR*)((UINT_PTR)TemporalPathBuffer + TemporalPathBufferSize - sizeof(WCHAR)) = L'\\';
											*(WCHAR*)((UINT_PTR)TemporalPathBuffer + TemporalPathBufferSize) = 0;
											TemporalPathBufferSize += sizeof(WCHAR);
										}
										Error = 0;
									}
									else
										Error = ERROR_INSUFFICIENT_BUFFER;
								}
								else
									Error = 0;
							}
							else
							{
								Error = GetLastError();
								if (!Error)
									Error = ERROR_NOT_SUPPORTED;
							}
						}
					}
					else
						Error = ERROR_NOT_SUPPORTED;
				break;
			}
			default :
			{
				TemporalPathBufferSize = snwuStringSize(Directory);
				BOOL AddSlash = File && TemporalPathBufferSize > sizeof(WCHAR) && *(const WCHAR*)((UINT_PTR)Directory + TemporalPathBufferSize - (2 * sizeof(WCHAR))) != L'\\' && *(const WCHAR*)((UINT_PTR)Directory + TemporalPathBufferSize - (2 * sizeof(WCHAR))) != L'/';
				if (TemporalPathBufferSize + (AddSlash ? 1 : 0) > TemporalPathBufferCapasity)
					Error = ERROR_INSUFFICIENT_BUFFER;
				else
				{
					snwuCopy(Directory, TemporalPathBuffer, TemporalPathBufferSize);
					if (AddSlash)
					{
						*(WCHAR*)((UINT_PTR)TemporalPathBuffer + TemporalPathBufferSize - sizeof(WCHAR)) = L'\\';
						*(WCHAR*)((UINT_PTR)TemporalPathBuffer + TemporalPathBufferSize) = 0;
						TemporalPathBufferSize += sizeof(WCHAR);
					}
					Error = 0;
				}
				break;
			}
		}
		if (Error)
		{
			if (Error == ERROR_INSUFFICIENT_BUFFER)
			{
				if (TemporalPathBufferSize < TemporalPathBufferCapasity)
					TemporalPathBufferCapasity += (MAX_PATH * sizeof(WCHAR));
				Error = _snwuInternalHeapReAlloc(Heap, (LPVOID*)&TemporalPathBuffer, &TemporalPathBufferCapasity);
			}
			if (!Error)
				Error = ERROR_INSUFFICIENT_BUFFER;
			else
			{
				if (CurrentProcessToken)
					CloseHandle(CurrentProcessToken);
				if (Userenv)
					FreeLibrary(Userenv);
				if (Shell32)
					FreeLibrary(Shell32);
				if (Ole32)
					FreeLibrary(Ole32);
				HeapFree(Heap, 0, TemporalPathBuffer);
				return Error;
			}
		}
	}
	if (CurrentProcessToken)
		CloseHandle(CurrentProcessToken);
	if (Userenv)
		FreeLibrary(Userenv);
	if (Shell32)
		FreeLibrary(Shell32);
	if (Ole32)
		FreeLibrary(Ole32);
	if (!_snwuInternalGetRootDirectoryNameSize(TemporalPathBuffer))
	{
		SIZE_T FullPathBufferCapasity = TemporalPathBufferSize + (MAX_PATH * sizeof(WCHAR));
		WCHAR* FullPathBuffer;
		Error = _snwuInternalHeapAlloc(Heap, (LPVOID*)&FullPathBuffer, &FullPathBufferCapasity);
		if (Error)
		{
			HeapFree(Heap, 0, TemporalPathBuffer);
			return Error;
		}
		for (;;)
		{
			SIZE_T FullPathBufferSize = (SIZE_T)GetFullPathNameW(TemporalPathBuffer, ((TemporalPathBufferCapasity - sizeof(WCHAR)) / sizeof(WCHAR)) < 0xFFFFFFFF ? (DWORD)((TemporalPathBufferCapasity - sizeof(WCHAR)) / sizeof(WCHAR)) : 0xFFFFFFFF, FullPathBuffer, 0) * sizeof(WCHAR);
			if (FullPathBufferSize && FullPathBufferSize < FullPathBufferCapasity - sizeof(WCHAR))
			{
				if (File && *(WCHAR*)((UINT_PTR)FullPathBuffer + FullPathBufferSize - sizeof(WCHAR)) != L'\\')
				{
					*(WCHAR*)((UINT_PTR)FullPathBuffer + FullPathBufferSize) = L'\\';
					*(WCHAR*)((UINT_PTR)FullPathBuffer + FullPathBufferSize + sizeof(WCHAR)) = 0;
					FullPathBufferSize += sizeof(WCHAR);
				}
				FullPathBufferSize += sizeof(WCHAR);
				HeapFree(Heap, 0, TemporalPathBuffer);
				TemporalPathBuffer = FullPathBuffer;
				TemporalPathBufferSize = FullPathBufferSize;
				TemporalPathBufferCapasity = FullPathBufferCapasity;
				break;
			}
			else if (FullPathBufferSize)
			{
				FullPathBufferCapasity = FullPathBufferSize;
				Error = _snwuInternalHeapReAlloc(Heap, (LPVOID*)&FullPathBuffer, &FullPathBufferCapasity);
				if (Error)
				{
					HeapFree(Heap, 0, FullPathBuffer);
					HeapFree(Heap, 0, TemporalPathBuffer);
					return Error;
				}
			}
			else
			{
				Error = GetLastError();
				HeapFree(Heap, 0, FullPathBuffer);
				HeapFree(Heap, 0, TemporalPathBuffer);
				return Error;
			}
		}
	}
	if (!File)
	{
		*PathSize = TemporalPathBufferSize;
		if (PathBufferSize < TemporalPathBufferSize)
		{
			HeapFree(Heap, 0, TemporalPathBuffer);
			return ERROR_INSUFFICIENT_BUFFER;
		}
		snwuCopy(TemporalPathBuffer, PathBuffer, TemporalPathBufferSize);
		HeapFree(Heap, 0, TemporalPathBuffer);
		return 0;
	}
	if (File == SNWU_FILE_UNIQUE_TEMPORAL)
	{
		TemporalPathBufferSize += ((SNWU_RANDOM_NAME_LENGHT + 4) * sizeof(WCHAR));
		*PathSize = TemporalPathBufferSize;
		if (PathBufferSize < TemporalPathBufferSize)
		{
			HeapFree(Heap, 0, TemporalPathBuffer);
			return ERROR_INSUFFICIENT_BUFFER;
		}
		snwuCopy(TemporalPathBuffer, PathBuffer, TemporalPathBufferSize - ((SNWU_RANDOM_NAME_LENGHT + 4) * sizeof(WCHAR)));
		Error = snwuCreateFileWithRandomName(0, 0, 0, FALSE, TRUE, PathBuffer, L".tmp");
		HeapFree(Heap, 0, TemporalPathBuffer);
		return Error;
	}
	TemporalPathBufferSize -= sizeof(WCHAR);
	SIZE_T FileNameSize = snwuStringSize(File);
	*PathSize = TemporalPathBufferSize + FileNameSize;
	if (PathBufferSize < TemporalPathBufferSize + FileNameSize)
	{
		HeapFree(Heap, 0, TemporalPathBuffer);
		return ERROR_INSUFFICIENT_BUFFER;
	}
	snwuCopy(TemporalPathBuffer, PathBuffer, TemporalPathBufferSize);
	snwuCopy(File, (VOID*)((UINT_PTR)PathBuffer + (UINT_PTR)TemporalPathBufferSize), FileNameSize);
	return 0;
}

DWORD snwuListDirectory(const WCHAR* DirectoryName, DWORD Flags, HANDLE Heap, SIZE_T* FileCount, WCHAR*** Files)
{
	const SIZE_T NodesPerAllocation = 64;
	const SIZE_T DefaultCharacterMemoryPerNode = (MAX_PATH + 1) * sizeof(WCHAR);
	const SIZE_T NodeAlignmentMask = ~(sizeof(DWORD) - 1);
	const SIZE_T FirstNodeOffset = (sizeof(WIN32_FIND_DATAW) + ~NodeAlignmentMask) & NodeAlignmentMask;
	const SIZE_T NodeHeaderSize = 4 * sizeof(DWORD);
	const SIZE_T PreviousNodeOffset = 0;
	const SIZE_T NextNodeOffset = sizeof(DWORD);
	const SIZE_T FileAttributesOffset = 2 * sizeof(DWORD);
	const SIZE_T PathNullTerminatorOffsetOffset = 3 * sizeof(DWORD);
	if (((Flags & (SNWU_LIST_DIRECTORY_FLAG_IGNORE_DIRECTORIES | SNWU_LIST_DIRECTORY_FLAG_IGNORE_FILES)) == (SNWU_LIST_DIRECTORY_FLAG_IGNORE_DIRECTORIES | SNWU_LIST_DIRECTORY_FLAG_IGNORE_FILES)) || ((Flags & (SNWU_LIST_DIRECTORY_FLAG_IGNORE_DIRECTORIES | SNWU_LIST_DIRECTORY_FLAG_INCLUDE_ROOT_DIRECTORY)) == (SNWU_LIST_DIRECTORY_FLAG_IGNORE_DIRECTORIES | SNWU_LIST_DIRECTORY_FLAG_INCLUDE_ROOT_DIRECTORY)))
		return ERROR_INVALID_PARAMETER;
	DWORD FileAttributes = GetFileAttributesW(DirectoryName);
	if (FileAttributes == INVALID_FILE_ATTRIBUTES)
		return GetLastError();
	else if (!(FileAttributes & FILE_ATTRIBUTE_DIRECTORY))
		return ERROR_INVALID_PARAMETER;
	SIZE_T NameSize = snwuStringSize(DirectoryName);
	if (NameSize < sizeof(WCHAR) || NameSize > _SNWU_INTERNAL_INPUT_PATH_SIZE_LIMIT)
		return ERROR_INVALID_PARAMETER;
	SIZE_T RoundedNameSize = ((NameSize + (2 * sizeof(WCHAR))) + ~NodeAlignmentMask) & NodeAlignmentMask;
	SIZE_T BufferSize = FirstNodeOffset + NodeHeaderSize + RoundedNameSize;
	SIZE_T BufferCapasity = BufferSize + (NodesPerAllocation * (NodeHeaderSize + (((NameSize + DefaultCharacterMemoryPerNode) + ~NodeAlignmentMask) & NodeAlignmentMask)));
	HANDLE ProcessHeap = GetProcessHeap();
	if (!ProcessHeap)
		return GetLastError();
	WIN32_FIND_DATAW* Buffer = (WIN32_FIND_DATAW*)HeapAlloc(ProcessHeap, 0, BufferCapasity);
	if (!Buffer)
		return GetLastError();
	SIZE_T GetBufferCapasity = HeapSize(ProcessHeap, 0, (LPVOID)Buffer);
	if (GetBufferCapasity != (SIZE_T)-1)
		BufferCapasity = GetBufferCapasity;
	*(DWORD*)((UINT_PTR)Buffer + FirstNodeOffset + PreviousNodeOffset) = 0;
	*(DWORD*)((UINT_PTR)Buffer + FirstNodeOffset + NextNodeOffset) = 0;
	*(DWORD*)((UINT_PTR)Buffer + FirstNodeOffset + FileAttributesOffset) = FileAttributes;
	*(DWORD*)((UINT_PTR)Buffer + FirstNodeOffset + PathNullTerminatorOffsetOffset) = (DWORD)(NameSize - sizeof(WCHAR));
	WCHAR* Name = (WCHAR*)((UINT_PTR)Buffer + FirstNodeOffset + NodeHeaderSize);
	snwuCopy(DirectoryName, Name, NameSize);
	DWORD Error;
	SIZE_T FullFileCount = 0;
	SIZE_T FullFileNameDataSize = 0;
	if (Flags & SNWU_LIST_DIRECTORY_FLAG_INCLUDE_ROOT_DIRECTORY)
	{
		FullFileCount = 1;
		FullFileNameDataSize = NameSize;
	}
	SIZE_T LastName = FirstNodeOffset;
	for (SIZE_T BufferIterator = LastName;;)
	{
		if (*(DWORD*)((UINT_PTR)Buffer + BufferIterator + FileAttributesOffset) & FILE_ATTRIBUTE_DIRECTORY)
		{
			SIZE_T CurrentDirectoryNameOffset = (SIZE_T)(BufferIterator + NodeHeaderSize);
			SIZE_T CurrentDirectoryNullTerminator = (SIZE_T)*(DWORD*)((UINT_PTR)Buffer + BufferIterator + PathNullTerminatorOffsetOffset);
			snwuCopy(L"\\*", (WCHAR*)((UINT_PTR)Buffer + CurrentDirectoryNameOffset + CurrentDirectoryNullTerminator), 3 * sizeof(WCHAR));
			HANDLE SearchHandle = FindFirstFileExW((WCHAR*)((UINT_PTR)Buffer + CurrentDirectoryNameOffset), FindExInfoBasic, Buffer, FindExSearchNameMatch, 0, 0);
			if (SearchHandle != INVALID_HANDLE_VALUE)
			{
				Error = 0;
				while (!Error)
				{
					SIZE_T FileNameSize = snwuStringSize(Buffer->cFileName);
					if (!(!(Buffer->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) && (Flags & SNWU_LIST_DIRECTORY_FLAG_IGNORE_FILES)) && !(FileNameSize == 2 * sizeof(WCHAR) && Buffer->cFileName[0] == L'.' && !Buffer->cFileName[1]) && !(FileNameSize == 3 * sizeof(WCHAR) && Buffer->cFileName[0] == L'.' && Buffer->cFileName[1] == L'.' && !Buffer->cFileName[2]))
					{
						FileAttributes = Buffer->dwFileAttributes;
						NameSize = CurrentDirectoryNullTerminator + sizeof(WCHAR) + FileNameSize;
						RoundedNameSize = ((NameSize + (FileAttributes & FILE_ATTRIBUTE_DIRECTORY ? (2 * sizeof(WCHAR)) : 0)) + ~NodeAlignmentMask) & NodeAlignmentMask;
						SIZE_T NewBufferSize = BufferSize + NodeHeaderSize + RoundedNameSize;
						if (BufferCapasity < NewBufferSize)
						{
							BufferCapasity += (NodesPerAllocation * ((NodeHeaderSize + RoundedNameSize) < (NodeHeaderSize + (((CurrentDirectoryNullTerminator + sizeof(WCHAR) + DefaultCharacterMemoryPerNode) + ~NodeAlignmentMask) & NodeAlignmentMask)) ? (NodeHeaderSize + (((CurrentDirectoryNullTerminator + sizeof(WCHAR) + DefaultCharacterMemoryPerNode) + ~NodeAlignmentMask) & NodeAlignmentMask)) : (NodeHeaderSize + RoundedNameSize)));
							WIN32_FIND_DATA* TemporalBuffer = (WIN32_FIND_DATA*)HeapReAlloc(ProcessHeap, 0, (LPVOID)Buffer, BufferCapasity);
							if (!TemporalBuffer)
							{
								Error = GetLastError();
								FindClose(SearchHandle);
								HeapFree(ProcessHeap, 0, (LPVOID)Buffer);
								return Error;
							}
							Buffer = TemporalBuffer;
							GetBufferCapasity = HeapSize(ProcessHeap, 0, (LPVOID)Buffer);
							if (GetBufferCapasity != (SIZE_T)-1)
								BufferCapasity = GetBufferCapasity;
						}
						*(DWORD*)((UINT_PTR)Buffer + LastName + NextNodeOffset) = (DWORD)(BufferSize - LastName);
						*(DWORD*)((UINT_PTR)Buffer + BufferSize + PreviousNodeOffset) = (DWORD)(BufferSize - LastName);
						*(DWORD*)((UINT_PTR)Buffer + BufferSize + NextNodeOffset) = 0;
						*(DWORD*)((UINT_PTR)Buffer + BufferSize + FileAttributesOffset) = FileAttributes;
						*(DWORD*)((UINT_PTR)Buffer + BufferSize + PathNullTerminatorOffsetOffset) = (DWORD)(NameSize - sizeof(WCHAR));
						Name = (WCHAR*)((UINT_PTR)Buffer + BufferSize + NodeHeaderSize);
						snwuCopy((WCHAR*)((UINT_PTR)Buffer + CurrentDirectoryNameOffset), Name, (CurrentDirectoryNullTerminator + sizeof(WCHAR)));
						snwuCopy(Buffer->cFileName, (WCHAR*)((UINT_PTR)Name + (CurrentDirectoryNullTerminator + sizeof(WCHAR))), FileNameSize);
						LastName = BufferSize;
						BufferSize = NewBufferSize;
						if (!(FileAttributes & FILE_ATTRIBUTE_DIRECTORY) || !(Flags & SNWU_LIST_DIRECTORY_FLAG_IGNORE_DIRECTORIES))
						{
							++FullFileCount;
							FullFileNameDataSize += NameSize;
						}
					}
					if (!FindNextFileW(SearchHandle, Buffer))
						Error = GetLastError();
				}
				FindClose(SearchHandle);
			}
			else
				Error = GetLastError();
			if (Error != ERROR_NO_MORE_FILES && !(Error == ERROR_ACCESS_DENIED && Flags & SNWU_LIST_DIRECTORY_FLAG_IGNORE_FIND_ACCESS_DENIED))
			{
				HeapFree(ProcessHeap, 0, (LPVOID)Buffer);
				return Error;
			}
			*(WCHAR*)((UINT_PTR)Buffer + CurrentDirectoryNameOffset + CurrentDirectoryNullTerminator) = 0;
		}
		SIZE_T BufferIteratorIncrement = (SIZE_T)*(DWORD*)((UINT_PTR)Buffer + BufferIterator + NextNodeOffset);
		if (BufferIteratorIncrement)
			BufferIterator += BufferIteratorIncrement;
		else
			break;
	}
	WCHAR** List = Heap ? (WCHAR**)HeapAlloc(Heap, 0, FullFileCount ? ((FullFileCount * sizeof(WCHAR*)) + FullFileNameDataSize) : 1) : (WCHAR**)VirtualAlloc(0, FullFileCount ? ((FullFileCount * sizeof(WCHAR*)) + FullFileNameDataSize) : 1, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	if (!List)
	{
		Error = GetLastError();
		HeapFree(ProcessHeap, 0, (LPVOID)Buffer);
		return Error;
	}
	UINT_PTR WriteOffset = (UINT_PTR)List + (FullFileCount * sizeof(WCHAR*));
	for (UINT_PTR WriteIndex = 0, BufferIterator = (UINT_PTR)Buffer + FirstNodeOffset + (!(Flags & SNWU_LIST_DIRECTORY_FLAG_INCLUDE_ROOT_DIRECTORY) ? (SIZE_T)*(DWORD*)((UINT_PTR)Buffer + FirstNodeOffset + NextNodeOffset) : 0); WriteIndex != FullFileCount; BufferIterator += (SIZE_T)*(DWORD*)(BufferIterator + NextNodeOffset))
		if (!(*(DWORD*)(BufferIterator + FileAttributesOffset) & FILE_ATTRIBUTE_DIRECTORY) || !(Flags & SNWU_LIST_DIRECTORY_FLAG_IGNORE_DIRECTORIES))
		{
			SIZE_T Size = (SIZE_T)*(DWORD*)(BufferIterator + PathNullTerminatorOffsetOffset) + sizeof(WCHAR);
			List[WriteIndex] = (WCHAR*)WriteOffset;
			snwuCopy((VOID*)(BufferIterator + NodeHeaderSize), (VOID*)List[WriteIndex], Size);
			WriteOffset += Size;
			++WriteIndex;
		}
	HeapFree(ProcessHeap, 0, (LPVOID)Buffer);
	*FileCount = FullFileCount;
	*Files = List;
	return 0;
}

DWORD snwuDeleteDirectory(const WCHAR* DirectoryName)
{
	const SIZE_T NodesPerAllocation = 64;
	const SIZE_T DefaultCharacterMemoryPerNode = (MAX_PATH + 1) * sizeof(WCHAR);
	const SIZE_T NodeAlignmentMask = ~(sizeof(DWORD) - 1);
	const SIZE_T FirstNodeOffset = (sizeof(WIN32_FIND_DATAW) + ~NodeAlignmentMask) & NodeAlignmentMask;
	const SIZE_T NodeHeaderSize = 4 * sizeof(DWORD);
	const SIZE_T PreviousNodeOffset = 0;
	const SIZE_T NextNodeOffset = sizeof(DWORD);
	const SIZE_T FileAttributesOffset = 2 * sizeof(DWORD);
	const SIZE_T PathNullTerminatorOffsetOffset = 3 * sizeof(DWORD);
	DWORD FileAttributes = GetFileAttributesW(DirectoryName);
	if (FileAttributes == INVALID_FILE_ATTRIBUTES)
		return GetLastError();
	else if (!(FileAttributes & FILE_ATTRIBUTE_DIRECTORY))
		return ERROR_INVALID_PARAMETER;
	SIZE_T ParentDirectoryNameSize = snwuStringSize(DirectoryName);
	if (ParentDirectoryNameSize < sizeof(WCHAR) || ParentDirectoryNameSize > _SNWU_INTERNAL_INPUT_PATH_SIZE_LIMIT)
		return ERROR_INVALID_PARAMETER;
	while (ParentDirectoryNameSize && *(WCHAR*)((UINT_PTR)DirectoryName + ParentDirectoryNameSize - sizeof(WCHAR)) != L'\\' && *(WCHAR*)((UINT_PTR)DirectoryName + ParentDirectoryNameSize - sizeof(WCHAR)) != L'/')
		ParentDirectoryNameSize -= sizeof(WCHAR);
	SIZE_T NameSize = ParentDirectoryNameSize + (13 * sizeof(WCHAR));
	SIZE_T RoundedNameSize = ((NameSize + (2 * sizeof(WCHAR))) + ~NodeAlignmentMask) & NodeAlignmentMask;
	SIZE_T BufferSize = FirstNodeOffset + NodeHeaderSize + RoundedNameSize;
	SIZE_T BufferCapasity = BufferSize + (NodesPerAllocation * (NodeHeaderSize + (((NameSize + DefaultCharacterMemoryPerNode) + ~NodeAlignmentMask) & NodeAlignmentMask)));
	HANDLE Heap = GetProcessHeap();
	if (!Heap)
		return GetLastError();
	WIN32_FIND_DATAW* Buffer = (WIN32_FIND_DATAW*)HeapAlloc(Heap, 0, BufferCapasity);
	if (!Buffer)
		return GetLastError();
	SIZE_T GetBufferCapasity = HeapSize(Heap, 0, (LPVOID)Buffer);
	if (GetBufferCapasity != (SIZE_T)-1)
		BufferCapasity = GetBufferCapasity;
	*(DWORD*)((UINT_PTR)Buffer + FirstNodeOffset + PreviousNodeOffset) = 0;
	*(DWORD*)((UINT_PTR)Buffer + FirstNodeOffset + NextNodeOffset) = 0;
	*(DWORD*)((UINT_PTR)Buffer + FirstNodeOffset + FileAttributesOffset) = FileAttributes;
	*(DWORD*)((UINT_PTR)Buffer + FirstNodeOffset + PathNullTerminatorOffsetOffset) = (DWORD)(NameSize - sizeof(WCHAR));
	WCHAR* Name = (WCHAR*)((UINT_PTR)Buffer + FirstNodeOffset + NodeHeaderSize);
	snwuCopy(DirectoryName, Name, NameSize - (13 * sizeof(WCHAR)));
	HANDLE RootDirectoryHandle = INVALID_HANDLE_VALUE;
	DWORD Error;
	while (RootDirectoryHandle == INVALID_HANDLE_VALUE)
	{
		*(WCHAR*)((UINT_PTR)Name + NameSize - (13 * sizeof(WCHAR))) = 0;
		Error = snwuCreateFileWithRandomName(0, 0, 0, TRUE, TRUE, Name, L".tmp");
		if (Error)
		{
			HeapFree(Heap, 0, (LPVOID)Buffer);
			return Error;
		}
		if (MoveFileW(DirectoryName, Name))
		{
			RootDirectoryHandle = CreateFileW(Name, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, 0);
			if (RootDirectoryHandle == INVALID_HANDLE_VALUE)
			{
				Error = GetLastError();
				MoveFileW(Name, DirectoryName);
				HeapFree(Heap, 0, (LPVOID)Buffer);
				return Error;
			}
		}
		else
		{
			Error = GetLastError();
			if (Error != ERROR_ALREADY_EXISTS)
			{
				HeapFree(Heap, 0, (LPVOID)Buffer);
				return Error;
			}
		}
	}
	SIZE_T LastName = FirstNodeOffset;
	for (SIZE_T BufferIterator = LastName;;)
	{
		if (*(DWORD*)((UINT_PTR)Buffer + BufferIterator + FileAttributesOffset) & FILE_ATTRIBUTE_DIRECTORY)
		{
			SIZE_T CurrentDirectoryNameOffset = (SIZE_T)(BufferIterator + NodeHeaderSize);
			SIZE_T CurrentDirectoryNullTerminator = (SIZE_T)*(DWORD*)((UINT_PTR)Buffer + BufferIterator + PathNullTerminatorOffsetOffset);
			snwuCopy(L"\\*", (WCHAR*)((UINT_PTR)Buffer + CurrentDirectoryNameOffset + CurrentDirectoryNullTerminator), 3 * sizeof(WCHAR));
			HANDLE SearchHandle = FindFirstFileExW((WCHAR*)((UINT_PTR)Buffer + CurrentDirectoryNameOffset), FindExInfoBasic, Buffer, FindExSearchNameMatch, 0, 0);
			if (SearchHandle != INVALID_HANDLE_VALUE)
			{
				Error = 0;
				while (!Error)
				{
					SIZE_T FileNameSize = snwuStringSize(Buffer->cFileName);
					if (!(FileNameSize == 2 * sizeof(WCHAR) && Buffer->cFileName[0] == L'.' && !Buffer->cFileName[1]) && !(FileNameSize == 3 * sizeof(WCHAR) && Buffer->cFileName[0] == L'.' && Buffer->cFileName[1] == L'.' && !Buffer->cFileName[2]))
					{
						FileAttributes = Buffer->dwFileAttributes;
						NameSize = CurrentDirectoryNullTerminator + sizeof(WCHAR) + FileNameSize;
						RoundedNameSize = ((NameSize + (FileAttributes & FILE_ATTRIBUTE_DIRECTORY ? (2 * sizeof(WCHAR)) : 0)) + ~NodeAlignmentMask) & NodeAlignmentMask;
						SIZE_T NewBufferSize = BufferSize + NodeHeaderSize + RoundedNameSize;
						if (BufferCapasity < NewBufferSize)
						{
							BufferCapasity += (NodesPerAllocation * ((NodeHeaderSize + RoundedNameSize) < (NodeHeaderSize + (((CurrentDirectoryNullTerminator + sizeof(WCHAR) + DefaultCharacterMemoryPerNode) + ~NodeAlignmentMask) & NodeAlignmentMask)) ? (NodeHeaderSize + (((CurrentDirectoryNullTerminator + sizeof(WCHAR) + DefaultCharacterMemoryPerNode) + ~NodeAlignmentMask) & NodeAlignmentMask)) : (NodeHeaderSize + RoundedNameSize)));
							WIN32_FIND_DATA* TemporalBuffer = (WIN32_FIND_DATA*)HeapReAlloc(Heap, 0, (LPVOID)Buffer, BufferCapasity);
							if (!TemporalBuffer)
							{
								Error = GetLastError();
								FindClose(SearchHandle);
								CloseHandle(RootDirectoryHandle);
								MoveFileW((WCHAR*)((UINT_PTR)Buffer + FirstNodeOffset + NodeHeaderSize), DirectoryName);
								HeapFree(Heap, 0, (LPVOID)Buffer);
								return Error;
							}
							Buffer = TemporalBuffer;
							GetBufferCapasity = HeapSize(Heap, 0, (LPVOID)Buffer);
							if (GetBufferCapasity != (SIZE_T)-1)
								BufferCapasity = GetBufferCapasity;
						}
						*(DWORD*)((UINT_PTR)Buffer + LastName + NextNodeOffset) = (DWORD)(BufferSize - LastName);
						*(DWORD*)((UINT_PTR)Buffer + BufferSize + PreviousNodeOffset) = (DWORD)(BufferSize - LastName);
						*(DWORD*)((UINT_PTR)Buffer + BufferSize + NextNodeOffset) = 0;
						*(DWORD*)((UINT_PTR)Buffer + BufferSize + FileAttributesOffset) = FileAttributes;
						*(DWORD*)((UINT_PTR)Buffer + BufferSize + PathNullTerminatorOffsetOffset) = (DWORD)(NameSize - sizeof(WCHAR));
						Name = (WCHAR*)((UINT_PTR)Buffer + BufferSize + NodeHeaderSize);
						snwuCopy((WCHAR*)((UINT_PTR)Buffer + CurrentDirectoryNameOffset), Name, (CurrentDirectoryNullTerminator + sizeof(WCHAR)));
						snwuCopy(Buffer->cFileName, (WCHAR*)((UINT_PTR)Name + (CurrentDirectoryNullTerminator + sizeof(WCHAR))), FileNameSize);
						LastName = BufferSize;
						BufferSize = NewBufferSize;
					}
					if (!FindNextFileW(SearchHandle, Buffer))
						Error = GetLastError();
				}
				FindClose(SearchHandle);
			}
			else
				Error = GetLastError();
			if (Error != ERROR_NO_MORE_FILES)
			{
				CloseHandle(RootDirectoryHandle);
				MoveFileW((WCHAR*)((UINT_PTR)Buffer + FirstNodeOffset + NodeHeaderSize), DirectoryName);
				HeapFree(Heap, 0, (LPVOID)Buffer);
				return Error;
			}
			*(WCHAR*)((UINT_PTR)Buffer + CurrentDirectoryNameOffset + CurrentDirectoryNullTerminator) = 0;
		}
		SIZE_T BufferIteratorIncrement = (SIZE_T)*(DWORD*)((UINT_PTR)Buffer + BufferIterator + NextNodeOffset);
		if (BufferIteratorIncrement)
			BufferIterator += BufferIteratorIncrement;
		else
			break;
	}
	Error = 0;
	for (UINT_PTR BufferIterator = (UINT_PTR)Buffer + LastName;;)
	{
		Name = (WCHAR*)(BufferIterator + NodeHeaderSize);
		FileAttributes = *(DWORD*)(BufferIterator + FileAttributesOffset);
		SIZE_T PreviousNode = (SIZE_T)*(DWORD*)(BufferIterator + PreviousNodeOffset);
		if (!PreviousNode)
			CloseHandle(RootDirectoryHandle);
		if (FileAttributes & FILE_ATTRIBUTE_READONLY)
			if (!SetFileAttributesW(Name, (FileAttributes & ~FILE_ATTRIBUTE_READONLY) ? (FileAttributes & ~FILE_ATTRIBUTE_READONLY) : FILE_ATTRIBUTE_NORMAL))
			{
				Error = GetLastError();
				if (PreviousNode)
					CloseHandle(RootDirectoryHandle);
				MoveFileW((WCHAR*)((UINT_PTR)Buffer + FirstNodeOffset + NodeHeaderSize), DirectoryName);
				HeapFree(Heap, 0, (LPVOID)Buffer);
				return Error;
			}
		if (!((FileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? RemoveDirectoryW(Name) : DeleteFileW(Name)))
		{
			Error = GetLastError();
			SetFileAttributesW(Name, FileAttributes);
			if (PreviousNode)
				CloseHandle(RootDirectoryHandle);
			MoveFileW((WCHAR*)((UINT_PTR)Buffer + FirstNodeOffset + NodeHeaderSize), DirectoryName);
			HeapFree(Heap, 0, (LPVOID)Buffer);
			return Error;
		}
		if (!PreviousNode)
		{
			HeapFree(Heap, 0, (LPVOID)Buffer);
			return 0;
		}
		BufferIterator -= PreviousNode;
	}
}

DWORD snwuCopyDirectory(const WCHAR* SourceDirectoryName, const WCHAR* DestinationDirectoryName)
{
	const SIZE_T NodesPerAllocation = 64;
	const SIZE_T DefaultCharacterMemoryPerNode = (MAX_PATH + 1) * sizeof(WCHAR);
	const SIZE_T NodeAlignmentMask = ~(sizeof(DWORD) - 1);
	const SIZE_T FirstNodeOffset = (sizeof(WIN32_FIND_DATAW) + ~NodeAlignmentMask) & NodeAlignmentMask;
	const SIZE_T NodeHeaderSize = 6 * sizeof(DWORD);
	const SIZE_T PreviousNodeOffset = 0;
	const SIZE_T NextNodeOffset = sizeof(DWORD);
	const SIZE_T FileAttributesOffset = 2 * sizeof(DWORD);
	const SIZE_T PathNullTerminatorOffsetOffset = 3 * sizeof(DWORD);
	const SIZE_T DestinationPathNullTerminatorOffset = 4 * sizeof(DWORD);
	const SIZE_T DestinationPathOffsetOffset = 5 * sizeof(DWORD);
	DWORD FileAttributes = GetFileAttributesW(DestinationDirectoryName);
	if (FileAttributes != INVALID_FILE_ATTRIBUTES)
		return ERROR_INVALID_PARAMETER;
	FileAttributes = GetFileAttributesW(SourceDirectoryName);
	if (FileAttributes == INVALID_FILE_ATTRIBUTES)
		return GetLastError();
	else if (!(FileAttributes & FILE_ATTRIBUTE_DIRECTORY))
		return ERROR_INVALID_PARAMETER;
	HANDLE SourceDirectoryHandle = CreateFileW(SourceDirectoryName, 0, FILE_SHARE_READ, 0, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, 0);
	if (SourceDirectoryHandle == INVALID_HANDLE_VALUE)
		return GetLastError();
	SIZE_T SourceNameSize = snwuStringSize(SourceDirectoryName);
	if (SourceNameSize < sizeof(WCHAR) || SourceNameSize > _SNWU_INTERNAL_INPUT_PATH_SIZE_LIMIT)
	{
		CloseHandle(SourceDirectoryHandle);
		return ERROR_INVALID_PARAMETER;
	}
	SIZE_T SourceExtendedNameSize = SourceNameSize + (2 * sizeof(WCHAR));
	SIZE_T DestinationParentNameSize = snwuStringSize(DestinationDirectoryName);
	if (DestinationParentNameSize < sizeof(WCHAR) || DestinationParentNameSize > _SNWU_INTERNAL_INPUT_PATH_SIZE_LIMIT)
	{
		CloseHandle(SourceDirectoryHandle);
		return ERROR_INVALID_PARAMETER;
	}
	while (DestinationParentNameSize && *(WCHAR*)((UINT_PTR)DestinationDirectoryName + DestinationParentNameSize - sizeof(WCHAR)) != L'\\' && *(WCHAR*)((UINT_PTR)DestinationDirectoryName + DestinationParentNameSize - sizeof(WCHAR)) != L'/')
		DestinationParentNameSize -= sizeof(WCHAR);
	SIZE_T DestinationNameSize = DestinationParentNameSize + (13 * sizeof(WCHAR));
	SIZE_T RoundedNameDataSize = ((SourceExtendedNameSize + DestinationNameSize) + ~NodeAlignmentMask) & NodeAlignmentMask;
	SIZE_T BufferSize = FirstNodeOffset + NodeHeaderSize + RoundedNameDataSize;
	SIZE_T BufferCapasity = BufferSize + (NodesPerAllocation * (NodeHeaderSize + (((SourceNameSize + DefaultCharacterMemoryPerNode + DestinationNameSize + DefaultCharacterMemoryPerNode) + ~NodeAlignmentMask) & NodeAlignmentMask)));
	HANDLE Heap = GetProcessHeap();
	if (!Heap)
	{
		CloseHandle(SourceDirectoryHandle);
		return GetLastError();
	}
	WIN32_FIND_DATAW* Buffer = (WIN32_FIND_DATAW*)HeapAlloc(Heap, 0, BufferCapasity);
	if (!Buffer)
	{
		CloseHandle(SourceDirectoryHandle);
		return GetLastError();
	}
	SIZE_T GetBufferCapasity = HeapSize(Heap, 0, (LPVOID)Buffer);
	if (GetBufferCapasity != (SIZE_T)-1)
		BufferCapasity = GetBufferCapasity;
	*(DWORD*)((UINT_PTR)Buffer + FirstNodeOffset + PreviousNodeOffset) = 0;
	*(DWORD*)((UINT_PTR)Buffer + FirstNodeOffset + NextNodeOffset) = 0;
	*(DWORD*)((UINT_PTR)Buffer + FirstNodeOffset + FileAttributesOffset) = FileAttributes;
	*(DWORD*)((UINT_PTR)Buffer + FirstNodeOffset + PathNullTerminatorOffsetOffset) = (DWORD)(SourceNameSize - sizeof(WCHAR));
	*(DWORD*)((UINT_PTR)Buffer + FirstNodeOffset + DestinationPathNullTerminatorOffset) = (DWORD)(DestinationNameSize - sizeof(WCHAR));
	*(DWORD*)((UINT_PTR)Buffer + FirstNodeOffset + DestinationPathOffsetOffset) = (DWORD)SourceExtendedNameSize;
	WCHAR* Name = (WCHAR*)((UINT_PTR)Buffer + FirstNodeOffset + NodeHeaderSize);
	snwuCopy(SourceDirectoryName, Name, SourceNameSize);
	Name = (WCHAR*)((UINT_PTR)Name + SourceExtendedNameSize);
	snwuCopy(DestinationDirectoryName, Name, DestinationParentNameSize);
	HANDLE DestinationDirectoryHandle;
	*(WCHAR*)((UINT_PTR)Name + DestinationParentNameSize) = 0;
	DWORD Error = snwuCreateFileWithRandomName(&DestinationDirectoryHandle, 0, FILE_SHARE_READ, TRUE, FALSE, Name, L"_TMP");
	if (Error)
	{
		HeapFree(Heap, 0, (LPVOID)Buffer);
		CloseHandle(SourceDirectoryHandle);
		return Error;
	}
	SIZE_T LastName = FirstNodeOffset;
	for (SIZE_T BufferIterator = LastName;;)
	{
		if (*(DWORD*)((UINT_PTR)Buffer + BufferIterator + FileAttributesOffset) & FILE_ATTRIBUTE_DIRECTORY)
		{
			SIZE_T CurrentDirectoryNameOffset = (SIZE_T)(BufferIterator + NodeHeaderSize);
			SIZE_T CurrentDirectoryNullTerminator = (SIZE_T)*(DWORD*)((UINT_PTR)Buffer + BufferIterator + PathNullTerminatorOffsetOffset);
			SIZE_T CurrentDestinationDirectoryNameOffset = (SIZE_T)(BufferIterator + NodeHeaderSize + (SIZE_T)*(DWORD*)((UINT_PTR)Buffer + BufferIterator + DestinationPathOffsetOffset));
			DestinationParentNameSize = (SIZE_T)*(DWORD*)((UINT_PTR)Buffer + BufferIterator + DestinationPathNullTerminatorOffset);
			snwuCopy(L"\\*", (WCHAR*)((UINT_PTR)Buffer + CurrentDirectoryNameOffset + CurrentDirectoryNullTerminator), 3 * sizeof(WCHAR));
			HANDLE SearchHandle = FindFirstFileExW((WCHAR*)((UINT_PTR)Buffer + CurrentDirectoryNameOffset), FindExInfoBasic, Buffer, FindExSearchNameMatch, 0, 0);
			if (SearchHandle != INVALID_HANDLE_VALUE)
			{
				Error = 0;
				while (!Error)
				{
					SIZE_T FileNameSize = snwuStringSize(Buffer->cFileName);
					if (!(FileNameSize == 2 * sizeof(WCHAR) && Buffer->cFileName[0] == L'.' && !Buffer->cFileName[1]) && !(FileNameSize == 3 * sizeof(WCHAR) && Buffer->cFileName[0] == L'.' && Buffer->cFileName[1] == L'.' && !Buffer->cFileName[2]))
					{
						FileAttributes = Buffer->dwFileAttributes;
						SourceNameSize = CurrentDirectoryNullTerminator + sizeof(WCHAR) + FileNameSize;
						SourceExtendedNameSize = SourceNameSize + (FileAttributes & FILE_ATTRIBUTE_DIRECTORY ? (2 * sizeof(WCHAR)) : 0);
						DestinationNameSize = DestinationParentNameSize + FileNameSize;
						RoundedNameDataSize = ((SourceExtendedNameSize + DestinationNameSize) + ~NodeAlignmentMask) & NodeAlignmentMask;
						SIZE_T NewBufferSize = BufferSize + NodeHeaderSize + RoundedNameDataSize;
						if (BufferCapasity < NewBufferSize)
						{
							BufferCapasity += (NodesPerAllocation * (NodeHeaderSize + (((SourceExtendedNameSize + ~NodeAlignmentMask) & NodeAlignmentMask) <
								(((CurrentDirectoryNullTerminator + sizeof(WCHAR) + DefaultCharacterMemoryPerNode) + ~NodeAlignmentMask) & NodeAlignmentMask) ?
								(((CurrentDirectoryNullTerminator + sizeof(WCHAR) + DefaultCharacterMemoryPerNode) + ~NodeAlignmentMask) & NodeAlignmentMask) :
								((SourceExtendedNameSize + ~NodeAlignmentMask) & NodeAlignmentMask)) +
								(((DestinationNameSize + ~NodeAlignmentMask) & NodeAlignmentMask) <
								(((DestinationParentNameSize + sizeof(WCHAR) + DefaultCharacterMemoryPerNode) + ~NodeAlignmentMask) & NodeAlignmentMask) ?
								(((DestinationParentNameSize + sizeof(WCHAR) + DefaultCharacterMemoryPerNode) + ~NodeAlignmentMask) & NodeAlignmentMask) :
								((DestinationNameSize + ~NodeAlignmentMask) & NodeAlignmentMask))));
							WIN32_FIND_DATA* TemporalBuffer = (WIN32_FIND_DATA*)HeapReAlloc(Heap, 0, (LPVOID)Buffer, BufferCapasity);
							if (!TemporalBuffer)
							{
								Error = GetLastError();
								FindClose(SearchHandle);
								CloseHandle(DestinationDirectoryHandle);
								RemoveDirectoryW((WCHAR*)((UINT_PTR)Buffer + FirstNodeOffset + NodeHeaderSize + (SIZE_T)*(DWORD*)((UINT_PTR)Buffer + FirstNodeOffset + DestinationPathOffsetOffset)));
								HeapFree(Heap, 0, (LPVOID)Buffer);
								CloseHandle(SourceDirectoryHandle);
								return Error;
							}
							Buffer = TemporalBuffer;
							GetBufferCapasity = HeapSize(Heap, 0, (LPVOID)Buffer);
							if (GetBufferCapasity != (SIZE_T)-1)
								BufferCapasity = GetBufferCapasity;
						}
						*(DWORD*)((UINT_PTR)Buffer + LastName + NextNodeOffset) = (DWORD)(BufferSize - LastName);
						*(DWORD*)((UINT_PTR)Buffer + BufferSize + PreviousNodeOffset) = (DWORD)(BufferSize - LastName);
						*(DWORD*)((UINT_PTR)Buffer + BufferSize + NextNodeOffset) = 0;
						*(DWORD*)((UINT_PTR)Buffer + BufferSize + FileAttributesOffset) = FileAttributes;
						*(DWORD*)((UINT_PTR)Buffer + BufferSize + PathNullTerminatorOffsetOffset) = (DWORD)(SourceNameSize - sizeof(WCHAR));
						*(DWORD*)((UINT_PTR)Buffer + BufferSize + DestinationPathNullTerminatorOffset) = (DWORD)(DestinationParentNameSize + FileNameSize);
						*(DWORD*)((UINT_PTR)Buffer + BufferSize + DestinationPathOffsetOffset) = (DWORD)SourceExtendedNameSize;
						Name = (WCHAR*)((UINT_PTR)Buffer + BufferSize + NodeHeaderSize);
						snwuCopy((WCHAR*)((UINT_PTR)Buffer + CurrentDirectoryNameOffset), Name, (CurrentDirectoryNullTerminator + sizeof(WCHAR)));
						snwuCopy(Buffer->cFileName, (WCHAR*)((UINT_PTR)Name + (CurrentDirectoryNullTerminator + sizeof(WCHAR))), FileNameSize);
						snwuCopy((WCHAR*)((UINT_PTR)Buffer + CurrentDestinationDirectoryNameOffset), (WCHAR*)((UINT_PTR)Name + SourceExtendedNameSize), DestinationParentNameSize);
						snwuCopy((WCHAR*)((UINT_PTR)Name + CurrentDirectoryNullTerminator), (WCHAR*)((UINT_PTR)Name + SourceExtendedNameSize + DestinationParentNameSize), sizeof(WCHAR) + FileNameSize);
						LastName = BufferSize;
						BufferSize = NewBufferSize;
					}
					if (!FindNextFileW(SearchHandle, Buffer))
						Error = GetLastError();
				}
				FindClose(SearchHandle);
			}
			else
				Error = GetLastError();
			if (Error != ERROR_NO_MORE_FILES)
			{
				CloseHandle(DestinationDirectoryHandle);
				RemoveDirectoryW((WCHAR*)((UINT_PTR)Buffer + FirstNodeOffset + NodeHeaderSize + (SIZE_T)*(DWORD*)((UINT_PTR)Buffer + FirstNodeOffset + DestinationPathOffsetOffset)));
				HeapFree(Heap, 0, (LPVOID)Buffer);
				CloseHandle(SourceDirectoryHandle);
				return Error;
			}
			*(WCHAR*)((UINT_PTR)Buffer + CurrentDirectoryNameOffset + CurrentDirectoryNullTerminator) = 0;
		}
		SIZE_T BufferIteratorIncrement = (SIZE_T)*(DWORD*)((UINT_PTR)Buffer + BufferIterator + NextNodeOffset);
		if (BufferIteratorIncrement)
			BufferIterator += BufferIteratorIncrement;
		else
			break;
	}
	if (*(DWORD*)((UINT_PTR)Buffer + FirstNodeOffset + NextNodeOffset))
	{
		UINT_PTR BufferIterator = (UINT_PTR)Buffer + FirstNodeOffset + (SIZE_T)*(DWORD*)((UINT_PTR)Buffer + FirstNodeOffset + NextNodeOffset);
		for (;;)
		{
			FileAttributes = *(DWORD*)((UINT_PTR)BufferIterator + FileAttributesOffset);
			Error = ((FileAttributes & FILE_ATTRIBUTE_DIRECTORY) ?
				CreateDirectoryExW((WCHAR*)(BufferIterator + NodeHeaderSize), (WCHAR*)(BufferIterator + NodeHeaderSize + (SIZE_T)*(DWORD*)((UINT_PTR)BufferIterator + DestinationPathOffsetOffset)), 0) :
				CopyFileW((WCHAR*)(BufferIterator + NodeHeaderSize), (WCHAR*)(BufferIterator + NodeHeaderSize + (SIZE_T)*(DWORD*)((UINT_PTR)BufferIterator + DestinationPathOffsetOffset)), TRUE)) ? 0 : GetLastError();
			if (Error)
			{
				BufferIterator -= (SIZE_T)*(DWORD*)((UINT_PTR)BufferIterator + PreviousNodeOffset);
				while (*(DWORD*)((UINT_PTR)BufferIterator + PreviousNodeOffset))
				{
					FileAttributes = *(DWORD*)((UINT_PTR)BufferIterator + FileAttributesOffset);
					Name = (WCHAR*)(BufferIterator + NodeHeaderSize + (SIZE_T)*(DWORD*)((UINT_PTR)BufferIterator + DestinationPathOffsetOffset));
					if (FileAttributes & FILE_ATTRIBUTE_READONLY)
						SetFileAttributesW(Name, (FileAttributes & ~FILE_ATTRIBUTE_READONLY) ? (FileAttributes & ~FILE_ATTRIBUTE_READONLY) : FILE_ATTRIBUTE_NORMAL);
					if (FileAttributes & FILE_ATTRIBUTE_DIRECTORY)
						RemoveDirectoryW(Name);
					else
						DeleteFileW(Name);
					BufferIterator -= (SIZE_T)*(DWORD*)((UINT_PTR)BufferIterator + PreviousNodeOffset);
				}
				CloseHandle(DestinationDirectoryHandle);
				RemoveDirectoryW((WCHAR*)((UINT_PTR)Buffer + FirstNodeOffset + NodeHeaderSize + (SIZE_T)*(DWORD*)((UINT_PTR)Buffer + FirstNodeOffset + DestinationPathOffsetOffset)));
				HeapFree(Heap, 0, (LPVOID)Buffer);
				CloseHandle(SourceDirectoryHandle);
				return Error;
			}
			SIZE_T NextNodeIncrement = (SIZE_T)*(DWORD*)(BufferIterator + NextNodeOffset);
			if (NextNodeIncrement)
				BufferIterator += (SIZE_T)*(DWORD*)(BufferIterator + NextNodeOffset);
			else
				break;
		}
	}
	CloseHandle(SourceDirectoryHandle);
	CloseHandle(DestinationDirectoryHandle);
	if (!MoveFileW((WCHAR*)((UINT_PTR)Buffer + FirstNodeOffset + NodeHeaderSize + (SIZE_T)*(DWORD*)((UINT_PTR)Buffer + FirstNodeOffset + DestinationPathOffsetOffset)), DestinationDirectoryName))
	{
		Error = GetLastError();
		UINT_PTR BufferIterator = (UINT_PTR)Buffer + LastName;
		while (*(DWORD*)((UINT_PTR)BufferIterator + PreviousNodeOffset))
		{
			FileAttributes = *(DWORD*)((UINT_PTR)BufferIterator + FileAttributesOffset);
			Name = (WCHAR*)(BufferIterator + NodeHeaderSize + (SIZE_T)*(DWORD*)((UINT_PTR)BufferIterator + DestinationPathOffsetOffset));
			if (FileAttributes & FILE_ATTRIBUTE_READONLY)
				SetFileAttributesW(Name, (FileAttributes & ~FILE_ATTRIBUTE_READONLY) ? (FileAttributes & ~FILE_ATTRIBUTE_READONLY) : FILE_ATTRIBUTE_NORMAL);
			if (FileAttributes & FILE_ATTRIBUTE_DIRECTORY)
				RemoveDirectoryW(Name);
			else
				DeleteFileW(Name);
			BufferIterator -= (SIZE_T)*(DWORD*)((UINT_PTR)BufferIterator + PreviousNodeOffset);
		}
		RemoveDirectoryW((WCHAR*)((UINT_PTR)Buffer + FirstNodeOffset + NodeHeaderSize + (SIZE_T)*(DWORD*)((UINT_PTR)Buffer + FirstNodeOffset + DestinationPathOffsetOffset)));
		HeapFree(Heap, 0, (LPVOID)Buffer);
		return Error;
	}
	HeapFree(Heap, 0, (LPVOID)Buffer);
	return 0;
}

DWORD snwuEnablePrivilege(const WCHAR* PrivilegeName, BOOL Enable)
{
	HANDLE Heap = GetProcessHeap();
	if (!Heap)
		return GetLastError();
	HANDLE Process = GetCurrentProcess();
	HANDLE ProcessToken;
	LUID PrivilegeIdentifier;
	if (!LookupPrivilegeValueW(0, PrivilegeName, &PrivilegeIdentifier) || !OpenProcessToken(Process, TOKEN_QUERY, &ProcessToken))
		return GetLastError();
	DWORD ProcessTokenInfoSize = 0;
	if (!GetTokenInformation(ProcessToken, TokenPrivileges, 0, 0, &ProcessTokenInfoSize) && GetLastError() != ERROR_INSUFFICIENT_BUFFER)
	{
		DWORD Error = GetLastError();
		CloseHandle(ProcessToken);
		return Error;
	}
	TOKEN_PRIVILEGES* ProcessTokenInfo = (TOKEN_PRIVILEGES*)HeapAlloc(Heap, 0, (SIZE_T)ProcessTokenInfoSize);
	if (!ProcessTokenInfo)
	{
		DWORD Error = GetLastError();
		CloseHandle(ProcessToken);
		return Error;
	}
	if (!GetTokenInformation(ProcessToken, TokenPrivileges, ProcessTokenInfo, ProcessTokenInfoSize, &ProcessTokenInfoSize))
	{
		DWORD Error = GetLastError();
		HeapFree(Heap, 0, ProcessTokenInfo);
		CloseHandle(ProcessToken);
		return Error;
	}
	CloseHandle(ProcessToken);
	for (LUID_AND_ATTRIBUTES* ProcessTokenInfoSearch = ProcessTokenInfo->Privileges, *ProcessTokenInfoEnd = ProcessTokenInfo->Privileges + (SIZE_T)ProcessTokenInfo->PrivilegeCount; ProcessTokenInfoSearch != ProcessTokenInfoEnd; ++ProcessTokenInfoSearch)
		if (*(ULONGLONG*)&ProcessTokenInfoSearch->Luid == *(ULONGLONG*)&PrivilegeIdentifier)
		{
			Enable = Enable ? TRUE : FALSE;
			BOOL PrivilegeEnabled = ProcessTokenInfoSearch->Attributes & SE_PRIVILEGE_ENABLED ? TRUE : FALSE;
			HeapFree(Heap, 0, ProcessTokenInfo);
			if (Enable != PrivilegeEnabled)
			{
				if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &ProcessToken))
					return GetLastError();
				TOKEN_PRIVILEGES NewPrivilegeState;
				NewPrivilegeState.PrivilegeCount = 1;
				NewPrivilegeState.Privileges[0].Luid = PrivilegeIdentifier;
				NewPrivilegeState.Privileges[0].Attributes = Enable ? SE_PRIVILEGE_ENABLED : 0;
				if (!AdjustTokenPrivileges(ProcessToken, 0, &NewPrivilegeState, sizeof(TOKEN_PRIVILEGES), 0, 0) || GetLastError() != ERROR_SUCCESS)
				{
					DWORD Error = GetLastError();
					CloseHandle(ProcessToken);
					return Error;
				}
				CloseHandle(ProcessToken);
			}
			return 0;
		}
	HeapFree(Heap, 0, ProcessTokenInfo);
	return ERROR_NOT_FOUND;
}

DWORD snwuDeleteRegistryTree(HKEY ParentKey, const WCHAR* SubKey)
{
	HMODULE Advapi32 = GetModuleHandleW(L"Advapi32.dll");
	if (Advapi32)
	{
		LONG (WINAPI* Advapi32_RegDeleteTreeW)(HKEY hKey, LPCTSTR lpSubKey) = (LONG (WINAPI*)(HKEY, LPCTSTR))GetProcAddress(Advapi32, "RegDeleteTreeW");
		if (Advapi32_RegDeleteTreeW && !Advapi32_RegDeleteTreeW(ParentKey, SubKey))
			return 0;
	}
	const SIZE_T NodesPerAllocation = 64;
	const SIZE_T DefaultCharacterMemoryPerName = (MAX_PATH + 1) * sizeof(WCHAR);
	const SIZE_T NodeAlignmentMask = ~(sizeof(DWORD) - 1);
	const SIZE_T NodeHeaderSize = 3 * sizeof(DWORD);
	const SIZE_T PreviousNodeOffset = 0;
	const SIZE_T NextNodeOffset = sizeof(DWORD);
	const SIZE_T PathNullTerminatorOffsetOffset = 2 * sizeof(DWORD);
	SIZE_T NameSize = snwuStringSize(SubKey);
	SIZE_T RoundedNameSize = (NameSize + ~NodeAlignmentMask) & NodeAlignmentMask;
	SIZE_T BufferSize = NodeHeaderSize + RoundedNameSize;
	SIZE_T BufferCapasity = BufferSize + (NodesPerAllocation * (NodeHeaderSize + (((NameSize + DefaultCharacterMemoryPerName) + ~NodeAlignmentMask) & NodeAlignmentMask)));
	HANDLE Heap = GetProcessHeap();
	if (!Heap)
		return GetLastError();
	UINT_PTR Buffer = (UINT_PTR)HeapAlloc(Heap, 0, BufferCapasity);
	if (!Buffer)
		return GetLastError();
	SIZE_T GetBufferCapasity = HeapSize(Heap, 0, (LPVOID)Buffer);
	if (GetBufferCapasity != (SIZE_T)-1)
		BufferCapasity = GetBufferCapasity;
	*(DWORD*)(Buffer + PreviousNodeOffset) = 0;
	*(DWORD*)(Buffer + NextNodeOffset) = 0;
	*(DWORD*)(Buffer + PathNullTerminatorOffsetOffset) = (DWORD)(NameSize - sizeof(WCHAR));
	snwuCopy(SubKey, (VOID*)(Buffer + NodeHeaderSize), NameSize);
	HKEY CurrentKey;
	SIZE_T LastName = 0;
	for (SIZE_T BufferIterator = LastName;;)
	{
		LONG Status = RegOpenKeyExW(ParentKey, (WCHAR*)(Buffer + BufferIterator + NodeHeaderSize), 0, KEY_ENUMERATE_SUB_KEYS, &CurrentKey);
		if (Status)
		{
			HeapFree(Heap, 0, (LPVOID)Buffer);
			return (DWORD)Status;
		}
		SIZE_T CurrentKeyNameNullTerminatorOffset = (SIZE_T)*(DWORD*)(Buffer + BufferIterator + PathNullTerminatorOffsetOffset);
		for (DWORD EnumerationIndex = 0; !Status;)
		{
			if (BufferCapasity < BufferSize + NodeHeaderSize + ((CurrentKeyNameNullTerminatorOffset + sizeof(WCHAR) + DefaultCharacterMemoryPerName + ~NodeAlignmentMask) & NodeAlignmentMask))
			{
				BufferCapasity += NodesPerAllocation * (NodeHeaderSize + (((CurrentKeyNameNullTerminatorOffset + sizeof(WCHAR) + DefaultCharacterMemoryPerName) + ~NodeAlignmentMask) & NodeAlignmentMask));
				UINT_PTR TemporalBuffer = (UINT_PTR)HeapReAlloc(Heap, 0, (LPVOID)Buffer, BufferCapasity);
				if (!TemporalBuffer)
				{
					DWORD Error = GetLastError();
					RegCloseKey(CurrentKey);
					HeapFree(Heap, 0, (LPVOID)Buffer);
					return Error;
				}
				Buffer = TemporalBuffer;
				GetBufferCapasity = HeapSize(Heap, 0, (LPVOID)Buffer);
				if (GetBufferCapasity != (SIZE_T)-1)
					BufferCapasity = GetBufferCapasity;
			}
			DWORD* NodeNameSize = (DWORD*)(Buffer + BufferSize + PathNullTerminatorOffsetOffset);
			*NodeNameSize = (DWORD)((BufferCapasity - (BufferSize + NodeHeaderSize + CurrentKeyNameNullTerminatorOffset + sizeof(WCHAR))) & NodeAlignmentMask) / sizeof(WCHAR);
			Status = RegEnumKeyExW(CurrentKey, EnumerationIndex, (WCHAR*)(Buffer + BufferSize + NodeHeaderSize + CurrentKeyNameNullTerminatorOffset + sizeof(WCHAR)), NodeNameSize, 0, 0, 0, 0);
			if (!Status)
			{
				NameSize = CurrentKeyNameNullTerminatorOffset + sizeof(WCHAR) + ((SIZE_T)*NodeNameSize * sizeof(WCHAR));
				*NodeNameSize = (DWORD)NameSize;
				NameSize += sizeof(WCHAR);
				RoundedNameSize = (NameSize + ~NodeAlignmentMask) & NodeAlignmentMask;
				snwuCopy((VOID*)(Buffer + BufferIterator + NodeHeaderSize), (VOID*)(Buffer + BufferSize + NodeHeaderSize), CurrentKeyNameNullTerminatorOffset);
				*(WCHAR*)(Buffer + BufferSize + NodeHeaderSize + CurrentKeyNameNullTerminatorOffset) = L'\\';
				SIZE_T NewBufferSize = BufferSize + NodeHeaderSize + RoundedNameSize;
				*(DWORD*)((UINT_PTR)Buffer + LastName + NextNodeOffset) = (DWORD)(BufferSize - LastName);
				*(DWORD*)((UINT_PTR)Buffer + BufferSize + PreviousNodeOffset) = (DWORD)(BufferSize - LastName);
				*(DWORD*)((UINT_PTR)Buffer + BufferSize + NextNodeOffset) = 0;
				LastName = BufferSize;
				BufferSize = NewBufferSize;
				++EnumerationIndex;
			}
			else if (Status == ERROR_MORE_DATA)
			{
				BufferCapasity += NodesPerAllocation * (NodeHeaderSize + (((CurrentKeyNameNullTerminatorOffset + DefaultCharacterMemoryPerName) + ~NodeAlignmentMask) & NodeAlignmentMask));
				UINT_PTR TemporalBuffer = (UINT_PTR)HeapReAlloc(Heap, 0, (LPVOID)Buffer, BufferCapasity);
				if (!TemporalBuffer)
				{
					DWORD Error = GetLastError();
					RegCloseKey(CurrentKey);
					HeapFree(Heap, 0, (LPVOID)Buffer);
					return Error;
				}
				Buffer = TemporalBuffer;
				GetBufferCapasity = HeapSize(Heap, 0, (LPVOID)Buffer);
				if (GetBufferCapasity != (SIZE_T)-1)
					BufferCapasity = GetBufferCapasity;
				Status = 0;
			}
		}
		RegCloseKey(CurrentKey);
		if (Status != ERROR_NO_MORE_ITEMS)
		{
			HeapFree(Heap, 0, (LPVOID)Buffer);
			return (DWORD)Status;
		}
		SIZE_T BufferIteratorIncrement = (SIZE_T)*(DWORD*)((UINT_PTR)Buffer + BufferIterator + NextNodeOffset);
		if (BufferIteratorIncrement)
			BufferIterator += BufferIteratorIncrement;
		else
			break;
	}
	for (UINT_PTR BufferIterator = (UINT_PTR)Buffer + LastName;;)
	{
		WCHAR* Name = (WCHAR*)(BufferIterator + NodeHeaderSize);
		LONG Status = RegDeleteKeyW(ParentKey, Name);
		if (Status)
		{
			HeapFree(Heap, 0, (LPVOID)Buffer);
			return (DWORD)Status;
		}
		SIZE_T PreviousNode = (SIZE_T)*(DWORD*)(BufferIterator + PreviousNodeOffset);
		if (!PreviousNode)
		{
			HeapFree(Heap, 0, (LPVOID)Buffer);
			return 0;
		}
		BufferIterator -= PreviousNode;
	}
}

DWORD snwuSelfDestruct()
{
	WCHAR SelfDestructPipeName[32] = { L'\\', L'\\',  L'.',  L'\\',  L'p',  L'i',  L'p',  L'e',  L'\\',  L'S',  L'N',  L'W',  L'U',  L'S',  L'D',  L'P',  L'U',  L'I',  L'_', 0, 0, 0, 0, 0, 0, 0, 0, L'.',  L'd',  L'l',  L'l', 0 };
	DWORD CurrentProcessIdentity = GetCurrentProcessId();
	for (DWORD Digit = 0; Digit != 8; ++Digit)
		SelfDestructPipeName[19 + Digit] = L"0123456789ABCDEF"[(CurrentProcessIdentity >> ((7 - Digit) << 2)) & 0xF];
	HANDLE Heap = GetProcessHeap();
	if (!Heap)
		return GetLastError();
	SIZE_T LibraryFileNameSize = (MAX_PATH + 1) * sizeof(WCHAR);
	WCHAR* LibraryFileName = (WCHAR*)HeapAlloc(Heap, 0, LibraryFileNameSize);
	if (!LibraryFileName)
		return GetLastError();
	SIZE_T GetLibraryFileNameSize = HeapSize(Heap, 0, LibraryFileName);
	if (GetLibraryFileNameSize != (SIZE_T)-1)
		LibraryFileNameSize = GetLibraryFileNameSize;
	for (;;)
	{
		SIZE_T UsedLibraryFileNameSize;
		DWORD Error = snwuCreateFilePath(LibraryFileNameSize, LibraryFileName, SNWU_DIRECTORY_TEMPORAL, SelfDestructPipeName + 9, &UsedLibraryFileNameSize);
		if (!Error)
		{
			LibraryFileNameSize = UsedLibraryFileNameSize - sizeof(WCHAR);
			break;
		}
		else if (Error == ERROR_INSUFFICIENT_BUFFER)
		{
			LibraryFileNameSize = UsedLibraryFileNameSize;
			WCHAR* TemporalLibraryFileName = (WCHAR*)HeapReAlloc(Heap, 0, LibraryFileName, LibraryFileNameSize);
			if (!TemporalLibraryFileName)
			{
				Error = GetLastError();
				HeapFree(Heap, 0, LibraryFileName);
				return Error;
			}
			LibraryFileName = TemporalLibraryFileName;
			GetLibraryFileNameSize = HeapSize(Heap, 0, LibraryFileName);
			if (GetLibraryFileNameSize != (SIZE_T)-1)
				LibraryFileNameSize = GetLibraryFileNameSize;
		}
		else if (Error)
		{
			HeapFree(Heap, 0, LibraryFileName);
			return Error;
		}
	}
	SIZE_T FileNameSize = (MAX_PATH + 1) * sizeof(WCHAR);
	WCHAR* FileName = (WCHAR*)HeapAlloc(Heap, 0, FileNameSize);
	if (!FileName)
	{
		DWORD Error = GetLastError();
		HeapFree(Heap, 0, LibraryFileName);
		return Error;
	}
	SIZE_T GetFileNameSize = HeapSize(Heap, 0, FileName);
	if (GetFileNameSize != (SIZE_T)-1)
		FileNameSize = GetFileNameSize;
	for (;;)
	{
		SIZE_T UsedFileNameSize = (SIZE_T)GetModuleFileNameW(0, FileName, (DWORD)(FileNameSize / sizeof(WCHAR))) * sizeof(WCHAR);
		if (UsedFileNameSize < FileNameSize)
		{
			FileNameSize = UsedFileNameSize;
			break;
		}
		else if (UsedFileNameSize)
		{
			FileNameSize += MAX_PATH * sizeof(WCHAR);
			WCHAR* TemporalFileName = (WCHAR*)HeapReAlloc(Heap, 0, FileName, FileNameSize);
			if (!TemporalFileName)
			{
				DWORD Error = GetLastError();
				HeapFree(Heap, 0, FileName);
				HeapFree(Heap, 0, LibraryFileName);
				return Error;
			}
			FileName = TemporalFileName;
			GetFileNameSize = HeapSize(Heap, 0, FileName);
			if (GetFileNameSize != (SIZE_T)-1)
				FileNameSize = GetFileNameSize;
		}
		else
		{
			DWORD Error = GetLastError();
			HeapFree(Heap, 0, FileName);
			HeapFree(Heap, 0, LibraryFileName);
			return Error;
		}
	}
	SIZE_T SystemDirectorySize = (MAX_PATH + 1) * sizeof(WCHAR);
	WCHAR* SystemDirectory = (WCHAR*)HeapAlloc(Heap, 0, SystemDirectorySize);
	if (!SystemDirectory)
	{
		DWORD Error = GetLastError();
		HeapFree(Heap, 0, FileName);
		HeapFree(Heap, 0, LibraryFileName);
		return Error;
	}
	SIZE_T GetSystemDirectorySize = HeapSize(Heap, 0, SystemDirectory);
	if (GetSystemDirectorySize != (SIZE_T)-1)
		SystemDirectorySize = GetSystemDirectorySize;
	for (;;)
	{
		SIZE_T UsedSystemDirectorySize = (SIZE_T)GetSystemDirectoryW(SystemDirectory, (UINT)(SystemDirectorySize / sizeof(WCHAR))) * sizeof(WCHAR);
		if (UsedSystemDirectorySize < SystemDirectorySize)
		{
			SystemDirectorySize = UsedSystemDirectorySize;
			break;
		}
		else if (UsedSystemDirectorySize)
		{
			SystemDirectorySize = UsedSystemDirectorySize;
			WCHAR* TemporalSystemDirectory = (WCHAR*)HeapReAlloc(Heap, 0, SystemDirectory, SystemDirectorySize);
			if (!TemporalSystemDirectory)
			{
				DWORD Error = GetLastError();
				HeapFree(Heap, 0, SystemDirectory);
				HeapFree(Heap, 0, FileName);
				HeapFree(Heap, 0, LibraryFileName);
				return Error;
			}
			SystemDirectory = TemporalSystemDirectory;
			GetSystemDirectorySize = HeapSize(Heap, 0, SystemDirectory);
			if (GetSystemDirectorySize != (SIZE_T)-1)
				SystemDirectorySize = GetSystemDirectorySize;
		}
		else
		{
			DWORD Error = GetLastError();
			HeapFree(Heap, 0, SystemDirectory);
			HeapFree(Heap, 0, FileName);
			HeapFree(Heap, 0, LibraryFileName);
			return Error;
		}
	}
	const WCHAR* CurrentEnviroment = GetEnvironmentStringsW();
	if (!CurrentEnviroment)
	{
		DWORD Error = GetLastError();
		HeapFree(Heap, 0, SystemDirectory);
		HeapFree(Heap, 0, FileName);
		HeapFree(Heap, 0, LibraryFileName);
		return Error;
	}
	const WCHAR* ReadEnviroment = CurrentEnviroment;
	while (*ReadEnviroment)
		ReadEnviroment = (const WCHAR*)((UINT_PTR)ReadEnviroment + snwuStringSize(ReadEnviroment));
	SIZE_T CurrentEnviromentSize = (SIZE_T)((UINT_PTR)ReadEnviroment - (UINT_PTR)CurrentEnviroment);
	WCHAR* Environment = (WCHAR*)HeapAlloc(Heap, 0, CurrentEnviromentSize + (64 * sizeof(WCHAR)) + FileNameSize);
	if (!Environment)
	{
		DWORD Error = GetLastError();
		FreeEnvironmentStringsW((WCHAR*)CurrentEnviroment);
		HeapFree(Heap, 0, SystemDirectory);
		HeapFree(Heap, 0, FileName);
		HeapFree(Heap, 0, LibraryFileName);
		return Error;
	}
	snwuCopy(CurrentEnviroment, Environment, CurrentEnviromentSize);
	snwuCopy(L"SNWUSDPUI_PIPE=", (void*)((UINT_PTR)Environment + CurrentEnviromentSize), 15 * sizeof(WCHAR));
	snwuCopy(SelfDestructPipeName, (void*)((UINT_PTR)Environment + CurrentEnviromentSize + (15 * sizeof(WCHAR))), 32 * sizeof(WCHAR));
	snwuCopy(L"SNWUSDPUI_FILE=", (void*)((UINT_PTR)Environment + CurrentEnviromentSize + (47 * sizeof(WCHAR))), 15 * sizeof(WCHAR));
	snwuCopy(FileName, (void*)((UINT_PTR)Environment + CurrentEnviromentSize + (62 * sizeof(WCHAR))), FileNameSize + sizeof(WCHAR));
	*(WCHAR*)((UINT_PTR)Environment + CurrentEnviromentSize + (63 * sizeof(WCHAR)) + FileNameSize) = 0;
	FreeEnvironmentStringsW((WCHAR*)CurrentEnviroment);
	WCHAR* Command = (WCHAR*)HeapAlloc(Heap, 0, (1 * sizeof(WCHAR)) + SystemDirectorySize + (16 * sizeof(WCHAR)) + LibraryFileNameSize + (15 * sizeof(WCHAR)));
	if (!Command)
	{
		DWORD Error = GetLastError();
		HeapFree(Heap, 0, Environment);
		HeapFree(Heap, 0, SystemDirectory);
		HeapFree(Heap, 0, FileName);
		HeapFree(Heap, 0, LibraryFileName);
		return Error;
	}
	*Command = L'\"';
	snwuCopy(SystemDirectory, Command + 1, SystemDirectorySize);
	snwuCopy(L"\\Rundll32.exe\" \"", Command + 1 + (SystemDirectorySize / sizeof(WCHAR)), 16 * sizeof(WCHAR));
	snwuCopy(LibraryFileName, Command + 1 + (SystemDirectorySize / sizeof(WCHAR)) + 16, LibraryFileNameSize);
	snwuCopy(L"\",SelfDestruct", Command + 1 + (SystemDirectorySize / sizeof(WCHAR)) + 16 + (LibraryFileNameSize / sizeof(WCHAR)), 15 * sizeof(WCHAR));
	HANDLE Pipe = CreateNamedPipeW(SelfDestructPipeName, PIPE_ACCESS_INBOUND, PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT | PIPE_REJECT_REMOTE_CLIENTS, 1, sizeof(DWORD), sizeof(DWORD), 0x10000, 0);
	if (Pipe == INVALID_HANDLE_VALUE)
	{
		DWORD Error = GetLastError();
		HeapFree(Heap, 0, Environment);
		HeapFree(Heap, 0, Command);
		HeapFree(Heap, 0, SystemDirectory);
		HeapFree(Heap, 0, FileName);
		HeapFree(Heap, 0, LibraryFileName);
		return Error;
	}
#ifdef _M_X64
	static const BYTE LibraryFileData[] = {
		0x4D, 0x5A, 0x90, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0, 0x00, 0x00, 0x00,
		0x0E, 0x1F, 0xBA, 0x0E, 0x00, 0xB4, 0x09, 0xCD, 0x21, 0xB8, 0x01, 0x4C, 0xCD, 0x21, 0x54, 0x68, 0x69, 0x73, 0x20, 0x70, 0x72, 0x6F, 0x67, 0x72, 0x61, 0x6D, 0x20, 0x63, 0x61, 0x6E, 0x6E, 0x6F, 0x74, 0x20, 0x62, 0x65, 0x20, 0x72, 0x75, 0x6E, 0x20, 0x69, 0x6E, 0x20, 0x44, 0x4F, 0x53, 0x20, 0x6D, 0x6F, 0x64, 0x65, 0x2E, 0x0D, 0x0D, 0x0A, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x0E, 0x33, 0x1F, 0xCB, 0x4A, 0x52, 0x71, 0x98, 0x4A, 0x52, 0x71, 0x98, 0x4A, 0x52, 0x71, 0x98, 0x68, 0x32, 0x70, 0x99, 0x49, 0x52, 0x71, 0x98, 0x4A, 0x52, 0x70, 0x98, 0x5A, 0x52, 0x71, 0x98, 0xE9, 0x31, 0x78, 0x99, 0x4B, 0x52, 0x71, 0x98, 0xE9, 0x31, 0x71, 0x99, 0x4B, 0x52, 0x71, 0x98, 0xE9, 0x31, 0x8E, 0x98, 0x4B, 0x52, 0x71, 0x98, 0xE9, 0x31, 0x73, 0x99, 0x4B, 0x52, 0x71, 0x98,
		0x52, 0x69, 0x63, 0x68, 0x4A, 0x52, 0x71, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x45, 0x00, 0x00, 0x64, 0x86, 0x04, 0x00, 0xD8, 0xA8, 0xAF, 0x59, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x22, 0x20, 0x0B, 0x02, 0x0E, 0x0B, 0x00, 0x08, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x60, 0x01, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x90, 0x23, 0x00, 0x00, 0x4C, 0x00, 0x00, 0x00, 0xDC, 0x23, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0xE0, 0x01, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x21, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2E, 0x74, 0x65, 0x78, 0x74, 0x00, 0x00, 0x00, 0x19, 0x07, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x60,
		0x2E, 0x72, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0xCC, 0x05, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x40, 0x2E, 0x70, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x40, 0x2E, 0x72, 0x73, 0x72, 0x63, 0x00, 0x00, 0x00, 0xE0, 0x01, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xB8, 0x01, 0x00, 0x00, 0x00, 0xC3, 0xCC, 0xCC, 0x48, 0x8B, 0xC4, 0x48, 0x89, 0x58, 0x08, 0x48, 0x89, 0x70, 0x10, 0x48, 0x89, 0x78, 0x18, 0x55, 0x41, 0x54, 0x41, 0x55, 0x41, 0x56, 0x41, 0x57, 0x48, 0x8D, 0xA8, 0x88, 0xFE, 0xFF, 0xFF, 0x48, 0x81, 0xEC, 0x50, 0x02, 0x00, 0x00, 0x45, 0x33, 0xF6, 0xC7, 0x44, 0x24, 0x40, 0x48, 0x89, 0x5C, 0x24, 0x48, 0x8D, 0x8D, 0x20, 0x01, 0x00, 0x00,
		0x4C, 0x89, 0x75, 0xD4, 0x4C, 0x89, 0x75, 0xEC, 0x4C, 0x89, 0x75, 0x1C, 0xC7, 0x44, 0x24, 0x44, 0x18, 0x55, 0x57, 0x41, 0xC7, 0x44, 0x24, 0x48, 0x54, 0x41, 0x56, 0x41, 0xC7, 0x44, 0x24, 0x4C, 0x57, 0x48, 0x83, 0xEC, 0x48, 0xC7, 0x44, 0x24, 0x50, 0x30, 0x48, 0xB9, 0x00, 0xC7, 0x44, 0x24, 0x58, 0x00, 0x00, 0x00, 0xC7, 0xC7, 0x44, 0x24, 0x5C, 0x44, 0x24, 0x60, 0x00, 0xC7, 0x44, 0x24,
		0x60, 0x00, 0x00, 0x00, 0x48, 0x48, 0xC7, 0x44, 0x24, 0x64, 0xB8, 0x00, 0x00, 0x00, 0xC7, 0x44, 0x24, 0x6C, 0x00, 0xFF, 0xD0, 0x48, 0x48, 0xC7, 0x44, 0x24, 0x70, 0xBF, 0x00, 0x00, 0x00, 0x48, 0xC7, 0x44, 0x24, 0x78, 0x00, 0x48, 0xBB, 0x00, 0xC7, 0x45, 0x80, 0x00, 0x00, 0x00, 0x49, 0x48, 0xC7, 0x45, 0x84, 0xBE, 0x00, 0x00, 0x00, 0x48, 0xC7, 0x45, 0x8C, 0x00, 0x48, 0xBD, 0x00, 0xC7,
		0x45, 0x94, 0x00, 0x00, 0x00, 0x49, 0x48, 0xC7, 0x45, 0x98, 0xBF, 0x00, 0x00, 0x00, 0xC7, 0x45, 0xA0, 0x00, 0x85, 0xC0, 0x74, 0x48, 0xC7, 0x45, 0xA4, 0x1B, 0x48, 0xB9, 0x00, 0xC7, 0x45, 0xAC, 0x00, 0x00, 0x00, 0x41, 0xC7, 0x45, 0xB0, 0xFF, 0xD7, 0x85, 0xC0, 0xC7, 0x45, 0xB4, 0x74, 0x0A, 0x48, 0x8B, 0xC7, 0x45, 0xB8, 0xCB, 0xFF, 0xD5, 0x83, 0xC7, 0x45, 0xBC, 0xF8, 0xFF, 0x75, 0x07,
		0xC7, 0x45, 0xC0, 0x41, 0xFF, 0xD6, 0x8B, 0xC7, 0x45, 0xC4, 0xC8, 0xFF, 0xD7, 0x48, 0xC7, 0x45, 0xC8, 0x83, 0x64, 0x24, 0x20, 0xC7, 0x45, 0xCC, 0x00, 0x4C, 0x8D, 0x4C, 0xC7, 0x45, 0xD0, 0x24, 0x68, 0x49, 0xBC, 0xC7, 0x45, 0xDC, 0x48, 0x8D, 0x54, 0x24, 0xC7, 0x45, 0xE0, 0x60, 0x49, 0x8B, 0xCC, 0xC7, 0x45, 0xE4, 0x41, 0xB8, 0x04, 0x00, 0xC7, 0x45, 0xE8, 0x00, 0x00, 0x48, 0xB8, 0xC7,
		0x45, 0xF4, 0xFF, 0xD0, 0x85, 0xC0, 0xC7, 0x45, 0xF8, 0x74, 0x07, 0x83, 0x7C, 0xC7, 0x45, 0xFC, 0x24, 0x68, 0x04, 0x74, 0xC7, 0x45, 0x00, 0x07, 0x41, 0xFF, 0xD6, 0xC7, 0x45, 0x04, 0x8B, 0xC8, 0xFF, 0xD7, 0xC7, 0x45, 0x08, 0x49, 0x8B, 0xCC, 0x48, 0x48, 0xC7, 0x45, 0x0C, 0xB8, 0x00, 0x00, 0x00, 0xC7, 0x45, 0x14, 0x00, 0xFF, 0xD0, 0x49, 0xC7, 0x45, 0x18, 0x8B, 0xCC, 0x48, 0xB8, 0xC7,
		0x45, 0x24, 0xFF, 0xD0, 0xEB, 0x1B, 0xC7, 0x45, 0x28, 0x48, 0x8B, 0xCB, 0x41, 0xC7, 0x45, 0x2C, 0xFF, 0xD7, 0x85, 0xC0, 0xC7, 0x45, 0x30, 0x75, 0x1B, 0xB9, 0x00, 0xC7, 0x45, 0x34, 0x04, 0x00, 0x00, 0x48, 0x48, 0xC7, 0x45, 0x38, 0xB8, 0x00, 0x00, 0x00, 0xC7, 0x45, 0x40, 0x00, 0xFF, 0xD0, 0x48, 0xC7, 0x45, 0x44, 0x8B, 0xCB, 0xFF, 0xD5, 0xC7, 0x45, 0x48, 0x83, 0xF8, 0xFF, 0x75, 0xC7,
		0x45, 0x4C, 0xDB, 0x33, 0xC9, 0xFF, 0xC7, 0x45, 0x50, 0xD7, 0x48, 0x8B, 0x5C, 0xC7, 0x45, 0x54, 0x24, 0x70, 0x48, 0x83, 0xC7, 0x45, 0x58, 0xC4, 0x30, 0x41, 0x5F, 0xC7, 0x45, 0x5C, 0x41, 0x5E, 0x41, 0x5C, 0x66, 0xC7, 0x45, 0x60, 0x5F, 0x5D, 0xC6, 0x45, 0x62, 0xC3, 0xFF, 0x15, 0x56, 0x0E, 0x00, 0x00, 0x44, 0x8B, 0xBD, 0x24, 0x01, 0x00, 0x00, 0x4C, 0x89, 0xBD, 0x88, 0x00, 0x00, 0x00,
		0xFF, 0x15, 0x62, 0x0E, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x83, 0x0E, 0x00, 0x00, 0x89, 0x45, 0x78, 0xFF, 0x15, 0x3A, 0x0E, 0x00, 0x00, 0x48, 0x8B, 0xD8, 0x48, 0x85, 0xC0, 0x75, 0x0F, 0xFF, 0x15, 0x1C, 0x0E, 0x00, 0x00, 0x8B, 0xC8, 0xFF, 0x15, 0x34, 0x0E, 0x00, 0x00, 0xCC, 0x48, 0x8D, 0x15, 0x7C, 0x0E, 0x00, 0x00, 0x48, 0x8B, 0xCB, 0xFF, 0x15, 0x1B, 0x0E, 0x00, 0x00, 0x48, 0x8D, 0x15,
		0x7C, 0x0E, 0x00, 0x00, 0x48, 0x8B, 0xCB, 0x4C, 0x8B, 0xE0, 0xFF, 0x15, 0x08, 0x0E, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x79, 0x0E, 0x00, 0x00, 0x48, 0x8B, 0xCB, 0x4C, 0x8B, 0xE8, 0xFF, 0x15, 0xF5, 0x0D, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x76, 0x0E, 0x00, 0x00, 0x48, 0x8B, 0xCB, 0x48, 0x89, 0x85, 0xA0, 0x00, 0x00, 0x00, 0xFF, 0x15, 0xDE, 0x0D, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x6F, 0x0E, 0x00,
		0x00, 0x48, 0x8B, 0xCB, 0x48, 0x89, 0x85, 0xA8, 0x00, 0x00, 0x00, 0xFF, 0x15, 0xC7, 0x0D, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x68, 0x0E, 0x00, 0x00, 0x48, 0x8B, 0xCB, 0x48, 0x89, 0x85, 0xB0, 0x00, 0x00, 0x00, 0xFF, 0x15, 0xB0, 0x0D, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x61, 0x0E, 0x00, 0x00, 0x48, 0x8B, 0xCB, 0x48, 0x89, 0x85, 0xB8, 0x00, 0x00, 0x00, 0xFF, 0x15, 0x99, 0x0D, 0x00, 0x00, 0x48,
		0x8D, 0x15, 0x62, 0x0E, 0x00, 0x00, 0x48, 0x8B, 0xCB, 0x48, 0x89, 0x85, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x15, 0x82, 0x0D, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x5F, 0x0E, 0x00, 0x00, 0x48, 0x8B, 0xCB, 0x48, 0x89, 0x85, 0xC8, 0x00, 0x00, 0x00, 0xFF, 0x15, 0x6B, 0x0D, 0x00, 0x00, 0x4C, 0x8D, 0x85, 0x80, 0x00, 0x00, 0x00, 0xB9, 0x06, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x08, 0xFD, 0xFF, 0xFF,
		0x48, 0x89, 0x85, 0xD0, 0x00, 0x00, 0x00, 0xFF, 0x15, 0x0B, 0x0D, 0x00, 0x00, 0x85, 0xC0, 0x75, 0x08, 0x41, 0xFF, 0xD5, 0x8B, 0xC8, 0x41, 0xFF, 0xD4, 0x41, 0xB8, 0x20, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x95, 0xE0, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x1B, 0x0E, 0x00, 0x00, 0xFF, 0x15, 0xFD, 0x0C, 0x00, 0x00, 0x83, 0xF8, 0x1F, 0x74, 0x08, 0xB9, 0x0D, 0x07, 0x00, 0x00, 0x41, 0xFF, 0xD4,
		0x83, 0xCA, 0xFF, 0x48, 0x8D, 0x8D, 0xE0, 0x00, 0x00, 0x00, 0xFF, 0x15, 0x28, 0x0D, 0x00, 0x00, 0x85, 0xC0, 0x75, 0x08, 0x41, 0xFF, 0xD5, 0x8B, 0xC8, 0x41, 0xFF, 0xD4, 0x4C, 0x89, 0x74, 0x24, 0x30, 0x48, 0x8D, 0x8D, 0xE0, 0x00, 0x00, 0x00, 0x44, 0x89, 0x74, 0x24, 0x28, 0x45, 0x33, 0xC9, 0x45, 0x33, 0xC0, 0xC7, 0x44, 0x24, 0x20, 0x03, 0x00, 0x00, 0x00, 0xBA, 0x00, 0x00, 0x00, 0x40,
		0xFF, 0x15, 0xB2, 0x0C, 0x00, 0x00, 0x48, 0x89, 0x85, 0x98, 0x00, 0x00, 0x00, 0x48, 0x83, 0xF8, 0xFF, 0x75, 0x08, 0x41, 0xFF, 0xD5, 0x8B, 0xC8, 0x41, 0xFF, 0xD4, 0x49, 0x8D, 0x5F, 0xFF, 0x41, 0xB9, 0x04, 0x00, 0x00, 0x00, 0x48, 0xF7, 0xD3, 0x49, 0x8D, 0xBF, 0x62, 0x05, 0x00, 0x00, 0x48, 0x23, 0xFB, 0x48, 0x89, 0x5D, 0x70, 0x48, 0x8B, 0xD7, 0x41, 0xB8, 0x00, 0x30, 0x00, 0x00, 0x33,
		0xC9, 0xFF, 0x15, 0x59, 0x0C, 0x00, 0x00, 0x48, 0x8B, 0xF0, 0x48, 0x85, 0xC0, 0xEB, 0x4B, 0x4D, 0x85, 0xF6, 0x74, 0x48, 0x33, 0xD2, 0x41, 0xB8, 0x00, 0x80, 0x00, 0x00, 0x48, 0x8B, 0xCE, 0xFF, 0x15, 0x23, 0x0C, 0x00, 0x00, 0x49, 0x8D, 0x86, 0x51, 0x04, 0x00, 0x00, 0x41, 0xB9, 0x04, 0x00, 0x00, 0x00, 0x48, 0x83, 0xE0, 0xC0, 0x49, 0x8D, 0xBF, 0x22, 0x01, 0x00, 0x00, 0x48, 0x03, 0xF8,
		0x41, 0xB8, 0x00, 0x30, 0x00, 0x00, 0x48, 0x23, 0xFB, 0x33, 0xC9, 0x48, 0x8B, 0xD7, 0xFF, 0x15, 0x0C, 0x0C, 0x00, 0x00, 0x48, 0x8B, 0xF0, 0x48, 0x85, 0xC0, 0x75, 0x08, 0x41, 0xFF, 0xD5, 0x8B, 0xC8, 0x41, 0xFF, 0xD4, 0x48, 0x8B, 0x8D, 0x80, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0xC7, 0x49, 0xD1, 0xE8, 0x48, 0x8B, 0xD6, 0xFF, 0x15, 0xEE, 0x0B, 0x00, 0x00, 0x44, 0x8B, 0xF0, 0x4D, 0x03, 0xF6,
		0x4C, 0x3B, 0xF7, 0x73, 0x8A, 0x49, 0x83, 0xC6, 0x02, 0xE9, 0xA7, 0x00, 0x00, 0x00, 0x4D, 0x85, 0xFF, 0x0F, 0x84, 0x96, 0x00, 0x00, 0x00, 0x48, 0x8B, 0xBD, 0x88, 0x00, 0x00, 0x00, 0x49, 0x8D, 0x47, 0x3F, 0x49, 0x03, 0xC6, 0x48, 0x81, 0xC7, 0x22, 0x01, 0x00, 0x00, 0x48, 0x83, 0xE0, 0xC0, 0x41, 0xB9, 0x04, 0x00, 0x00, 0x00, 0x48, 0x03, 0xF8, 0x41, 0xB8, 0x00, 0x30, 0x00, 0x00, 0x48,
		0x23, 0x7D, 0x70, 0x33, 0xC9, 0x48, 0x8B, 0xD7, 0xFF, 0x15, 0x92, 0x0B, 0x00, 0x00, 0x45, 0x33, 0xFF, 0x48, 0x8B, 0xD8, 0x48, 0x85, 0xC0, 0x75, 0x08, 0x41, 0xFF, 0xD5, 0x8B, 0xC8, 0x41, 0xFF, 0xD4, 0x49, 0x8B, 0xCE, 0x49, 0x8D, 0x04, 0x36, 0x48, 0xD1, 0xE9, 0x48, 0x8B, 0xD3, 0x48, 0x3B, 0xF0, 0x4D, 0x8B, 0xCF, 0x49, 0x0F, 0x47, 0xCF, 0x48, 0x85, 0xC9, 0x74, 0x1A, 0x4C, 0x8B, 0xC6,
		0x4C, 0x2B, 0xC3, 0x41, 0x0F, 0xB7, 0x04, 0x10, 0x49, 0xFF, 0xC1, 0x66, 0x89, 0x02, 0x48, 0x8D, 0x52, 0x02, 0x4C, 0x3B, 0xC9, 0x75, 0xEC, 0x33, 0xD2, 0x41, 0xB8, 0x00, 0x80, 0x00, 0x00, 0x48, 0x8B, 0xCE, 0xFF, 0x15, 0x20, 0x0B, 0x00, 0x00, 0x48, 0x8B, 0xF3, 0xEB, 0x08, 0x41, 0xFF, 0xD5, 0x8B, 0xC8, 0x41, 0xFF, 0xD4, 0x48, 0x8B, 0xDF, 0x49, 0x8D, 0x14, 0x36, 0x49, 0x2B, 0xDE, 0x48,
		0x8D, 0x0D, 0x62, 0x0C, 0x00, 0x00, 0x4C, 0x8B, 0xC3, 0x49, 0xD1, 0xE8, 0xFF, 0x15, 0x1E, 0x0B, 0x00, 0x00, 0x44, 0x8B, 0xF8, 0x4D, 0x03, 0xFF, 0x4C, 0x3B, 0xFB, 0x0F, 0x83, 0x2D, 0xFF, 0xFF, 0xFF, 0x49, 0x83, 0xC7, 0x02, 0x49, 0x8D, 0x5E, 0x3F, 0x49, 0x03, 0xDF, 0x48, 0x8B, 0xC7, 0x48, 0x83, 0xE3, 0xC0, 0x48, 0x2B, 0xC3, 0x48, 0x3D, 0x23, 0x01, 0x00, 0x00, 0x0F, 0x83, 0x9B, 0x00,
		0x00, 0x00, 0x48, 0x8B, 0xBD, 0x88, 0x00, 0x00, 0x00, 0x41, 0xB9, 0x04, 0x00, 0x00, 0x00, 0x48, 0x81, 0xC7, 0x22, 0x01, 0x00, 0x00, 0x41, 0xB8, 0x00, 0x30, 0x00, 0x00, 0x48, 0x03, 0xFB, 0x33, 0xC9, 0x48, 0x23, 0x7D, 0x70, 0x48, 0x8B, 0xD7, 0xFF, 0x15, 0xB2, 0x0A, 0x00, 0x00, 0x48, 0x89, 0x45, 0x70, 0x48, 0x85, 0xC0, 0x75, 0x0C, 0x41, 0xFF, 0xD5, 0x8B, 0xC8, 0x41, 0xFF, 0xD4, 0x48,
		0x8B, 0x45, 0x70, 0x4B, 0x8D, 0x0C, 0x37, 0x4C, 0x8B, 0xC0, 0x45, 0x33, 0xFF, 0x48, 0x03, 0xCE, 0x48, 0x8B, 0xD1, 0x45, 0x8B, 0xCF, 0x48, 0x2B, 0xD6, 0x48, 0xFF, 0xC2, 0x48, 0xD1, 0xEA, 0x48, 0x3B, 0xF1, 0x49, 0x0F, 0x47, 0xD7, 0x48, 0x85, 0xD2, 0x74, 0x1B, 0x48, 0x8B, 0xCE, 0x48, 0x2B, 0xC8, 0x42, 0x0F, 0xB7, 0x04, 0x01, 0x49, 0xFF, 0xC1, 0x66, 0x41, 0x89, 0x00, 0x4D, 0x8D, 0x40,
		0x02, 0x4C, 0x3B, 0xCA, 0x75, 0xEB, 0x33, 0xD2, 0x41, 0xB8, 0x00, 0x80, 0x00, 0x00, 0x48, 0x8B, 0xCE, 0xFF, 0x15, 0x31, 0x0A, 0x00, 0x00, 0x48, 0x8B, 0x75, 0x70, 0xEB, 0x03, 0x45, 0x33, 0xFF, 0x48, 0x03, 0xDE, 0x48, 0x8D, 0x4D, 0x63, 0x48, 0x8D, 0x44, 0x24, 0x40, 0x49, 0x8B, 0xD7, 0x48, 0x3B, 0xC8, 0x4C, 0x8D, 0x44, 0x24, 0x40, 0x48, 0x1B, 0xC9, 0x48, 0xF7, 0xD1, 0x81, 0xE1, 0x23,
		0x01, 0x00, 0x00, 0x41, 0x8A, 0x00, 0x49, 0xFF, 0xC0, 0x88, 0x04, 0x1A, 0x48, 0xFF, 0xC2, 0x48, 0x3B, 0xD1, 0x75, 0xEF, 0x8B, 0x45, 0x78, 0x48, 0x8D, 0x95, 0x80, 0x00, 0x00, 0x00, 0x89, 0x43, 0x1F, 0x4D, 0x8D, 0x0C, 0x36, 0x48, 0x8B, 0x85, 0x98, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x4B, 0x13, 0x48, 0x89, 0x83, 0x94, 0x00, 0x00, 0x00, 0x48, 0x2B, 0xD3, 0x41, 0xB8, 0x08, 0x00, 0x00, 0x00,
		0x8A, 0x44, 0x0A, 0xED, 0x88, 0x01, 0x48, 0xFF, 0xC1, 0x49, 0x83, 0xE8, 0x01, 0x75, 0xF1, 0x48, 0x8B, 0x85, 0xA0, 0x00, 0x00, 0x00, 0x41, 0xB8, 0x20, 0x00, 0x00, 0x00, 0x48, 0x89, 0x73, 0x67, 0x48, 0x8B, 0xD7, 0x4C, 0x89, 0x4B, 0x3B, 0x48, 0x8B, 0xCE, 0x4C, 0x89, 0x63, 0x31, 0x4C, 0x8D, 0x8D, 0x90, 0x00, 0x00, 0x00, 0x4C, 0x89, 0x6B, 0x45, 0x48, 0x89, 0x43, 0x25, 0x48, 0x8B, 0x85,
		0xA8, 0x00, 0x00, 0x00, 0x48, 0x89, 0x43, 0x59, 0x48, 0x8B, 0x85, 0xB0, 0x00, 0x00, 0x00, 0x48, 0x89, 0x83, 0xDC, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x85, 0xB8, 0x00, 0x00, 0x00, 0x48, 0x89, 0x83, 0xAC, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x85, 0xC0, 0x00, 0x00, 0x00, 0x48, 0x89, 0x83, 0xCD, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x85, 0xC8, 0x00, 0x00, 0x00, 0x48, 0x89, 0x43, 0x4F, 0x48, 0x8B, 0x85,
		0xD0, 0x00, 0x00, 0x00, 0x48, 0x89, 0x83, 0xF9, 0x00, 0x00, 0x00, 0xFF, 0x15, 0x2F, 0x09, 0x00, 0x00, 0x85, 0xC0, 0x74, 0x19, 0xFF, 0x15, 0x35, 0x09, 0x00, 0x00, 0x4C, 0x8B, 0xC7, 0x48, 0x8B, 0xD6, 0x48, 0x8B, 0xC8, 0xFF, 0x15, 0x86, 0x09, 0x00, 0x00, 0x85, 0xC0, 0x75, 0x08, 0x41, 0xFF, 0xD5, 0x8B, 0xC8, 0x41, 0xFF, 0xD4, 0xFF, 0xD3, 0x4C, 0x8D, 0x9C, 0x24, 0x50, 0x02, 0x00, 0x00,
		0x49, 0x8B, 0x5B, 0x30, 0x49, 0x8B, 0x73, 0x38, 0x49, 0x8B, 0x7B, 0x40, 0x49, 0x8B, 0xE3, 0x41, 0x5F, 0x41, 0x5E, 0x41, 0x5D, 0x41, 0x5C, 0x5D, 0xC3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x90, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA2, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB0, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC4, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xDA, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xEA, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1A, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x28, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4E, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5E, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x94, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAC, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4B, 0x00, 0x65, 0x00, 0x72, 0x00, 0x6E, 0x00, 0x65, 0x00, 0x6C, 0x00, 0x33, 0x00, 0x32, 0x00, 0x2E, 0x00, 0x64, 0x00, 0x6C, 0x00, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x78, 0x69, 0x74, 0x50, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x47, 0x65, 0x74, 0x4C, 0x61, 0x73, 0x74, 0x45, 0x72, 0x72, 0x6F, 0x72, 0x00, 0x00, 0x00, 0x00, 0x46, 0x72, 0x65, 0x65, 0x4C, 0x69, 0x62, 0x72, 0x61, 0x72, 0x79, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x65, 0x6C, 0x65, 0x74, 0x65, 0x46, 0x69, 0x6C, 0x65, 0x57, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43, 0x6C, 0x6F, 0x73, 0x65, 0x48, 0x61, 0x6E, 0x64, 0x6C, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x57, 0x72, 0x69, 0x74, 0x65, 0x46, 0x69, 0x6C, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x6C, 0x75, 0x73, 0x68, 0x46, 0x69, 0x6C, 0x65, 0x42, 0x75, 0x66, 0x66, 0x65, 0x72, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0x65, 0x74, 0x46, 0x69, 0x6C, 0x65, 0x41, 0x74, 0x74, 0x72, 0x69, 0x62, 0x75, 0x74, 0x65, 0x73, 0x57, 0x00, 0x00, 0x53, 0x6C, 0x65, 0x65,
		0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x53, 0x00, 0x4E, 0x00, 0x57, 0x00, 0x55, 0x00, 0x53, 0x00, 0x44, 0x00, 0x50, 0x00, 0x55, 0x00, 0x49, 0x00, 0x5F, 0x00, 0x50, 0x00, 0x49, 0x00, 0x50, 0x00, 0x45, 0x00, 0x00, 0x00, 0x00, 0x00, 0x53, 0x00, 0x4E, 0x00, 0x57, 0x00, 0x55, 0x00, 0x53, 0x00, 0x44, 0x00, 0x50, 0x00, 0x55, 0x00, 0x49, 0x00, 0x5F, 0x00, 0x46, 0x00, 0x49, 0x00,
		0x4C, 0x00, 0x45, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD8, 0xA8, 0xAF, 0x59, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD8, 0xA8, 0xAF, 0x59, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00,
		0x54, 0x22, 0x00, 0x00, 0x54, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD8, 0xA8, 0xAF, 0x59, 0x00, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x00, 0x00, 0x68, 0x22, 0x00, 0x00, 0x68, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD8, 0xA8, 0xAF, 0x59, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x52, 0x53, 0x44, 0x53, 0x0E, 0x04, 0xE0, 0x25, 0x50, 0x90, 0xD8, 0x42, 0xB5, 0xBB, 0x92, 0x39, 0xA0, 0xE2, 0x28, 0x00, 0x04, 0x00, 0x00, 0x00, 0x43, 0x3A, 0x5C, 0x55, 0x73, 0x65, 0x72, 0x73, 0x5C, 0x53, 0x61, 0x6E, 0x74, 0x74, 0x75, 0x20, 0x4E, 0x79, 0x6D, 0x61, 0x6E, 0x5C, 0x44, 0x65, 0x73, 0x6B, 0x74, 0x6F, 0x70, 0x5C, 0x53, 0x4E, 0x57, 0x55, 0x53, 0x44, 0x5C, 0x78, 0x36, 0x34,
		0x5C, 0x52, 0x65, 0x6C, 0x65, 0x61, 0x73, 0x65, 0x5C, 0x53, 0x4E, 0x57, 0x55, 0x53, 0x44, 0x2E, 0x70, 0x64, 0x62, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0x43, 0x54, 0x4C, 0x00, 0x10, 0x00, 0x00, 0x19, 0x07, 0x00, 0x00, 0x2E, 0x74, 0x65, 0x78, 0x74, 0x24, 0x6D, 0x6E, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x20, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 0x2E, 0x69, 0x64, 0x61, 0x74, 0x61, 0x24, 0x35, 0x00, 0x00, 0x00, 0x00, 0x90, 0x20, 0x00, 0x00, 0x70, 0x01, 0x00, 0x00, 0x2E, 0x72, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x64, 0x01, 0x00, 0x00, 0x2E, 0x72, 0x64, 0x61, 0x74, 0x61, 0x24, 0x7A, 0x7A, 0x7A, 0x64, 0x62, 0x67, 0x00, 0x00, 0x00, 0x64, 0x23, 0x00, 0x00,
		0x2C, 0x00, 0x00, 0x00, 0x2E, 0x78, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0x90, 0x23, 0x00, 0x00, 0x4C, 0x00, 0x00, 0x00, 0x2E, 0x65, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0xDC, 0x23, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x2E, 0x69, 0x64, 0x61, 0x74, 0x61, 0x24, 0x32, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x23, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x2E, 0x69, 0x64, 0x61, 0x74, 0x61, 0x24, 0x33,
		0x00, 0x00, 0x00, 0x00, 0x08, 0x24, 0x00, 0x00, 0x88, 0x00, 0x00, 0x00, 0x2E, 0x69, 0x64, 0x61, 0x74, 0x61, 0x24, 0x34, 0x00, 0x00, 0x00, 0x00, 0x90, 0x24, 0x00, 0x00, 0x3C, 0x01, 0x00, 0x00, 0x2E, 0x69, 0x64, 0x61, 0x74, 0x61, 0x24, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x2E, 0x70, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00,
		0x60, 0x00, 0x00, 0x00, 0x2E, 0x72, 0x73, 0x72, 0x63, 0x24, 0x30, 0x31, 0x00, 0x00, 0x00, 0x00, 0x60, 0x40, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x2E, 0x72, 0x73, 0x72, 0x63, 0x24, 0x30, 0x32, 0x00, 0x00, 0x00, 0x00, 0x01, 0x26, 0x0D, 0x00, 0x26, 0x74, 0x52, 0x00, 0x26, 0x64, 0x51, 0x00, 0x26, 0x34, 0x50, 0x00, 0x26, 0x01, 0x4A, 0x00, 0x18, 0xF0, 0x16, 0xE0, 0x14, 0xD0, 0x12, 0xC0,
		0x10, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xC2, 0x23, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xB8, 0x23, 0x00, 0x00, 0xBC, 0x23, 0x00, 0x00, 0xC0, 0x23, 0x00, 0x00, 0x08, 0x10, 0x00, 0x00, 0xCD, 0x23, 0x00, 0x00,
		0x00, 0x00, 0x53, 0x4E, 0x57, 0x55, 0x53, 0x44, 0x2E, 0x64, 0x6C, 0x6C, 0x00, 0x53, 0x65, 0x6C, 0x66, 0x44, 0x65, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x00, 0x00, 0x00, 0x08, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xBE, 0x25, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA2, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB0, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC4, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xDA, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xEA, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x1A, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4E, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5E, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x94, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xAC, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xCB, 0x05, 0x56, 0x69, 0x72, 0x74, 0x75, 0x61, 0x6C, 0x50, 0x72, 0x6F, 0x74, 0x65, 0x63, 0x74, 0x00, 0x00, 0xC8, 0x05, 0x56, 0x69, 0x72, 0x74, 0x75, 0x61, 0x6C, 0x46, 0x72, 0x65, 0x65, 0x00, 0x19, 0x02, 0x47, 0x65, 0x74, 0x43, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x50, 0x72, 0x6F, 0x63,
		0x65, 0x73, 0x73, 0x00, 0x76, 0x02, 0x47, 0x65, 0x74, 0x4D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x48, 0x61, 0x6E, 0x64, 0x6C, 0x65, 0x45, 0x78, 0x57, 0x00, 0x00, 0xC5, 0x05, 0x56, 0x69, 0x72, 0x74, 0x75, 0x61, 0x6C, 0x41, 0x6C, 0x6C, 0x6F, 0x63, 0x00, 0x00, 0x73, 0x02, 0x47, 0x65, 0x74, 0x4D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x46, 0x69, 0x6C, 0x65, 0x4E, 0x61, 0x6D, 0x65, 0x57, 0x00, 0x00,
		0x3A, 0x02, 0x47, 0x65, 0x74, 0x45, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x56, 0x61, 0x72, 0x69, 0x61, 0x62, 0x6C, 0x65, 0x57, 0x00, 0xC9, 0x00, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x46, 0x69, 0x6C, 0x65, 0x57, 0x00, 0x60, 0x02, 0x47, 0x65, 0x74, 0x4C, 0x61, 0x73, 0x74, 0x45, 0x72, 0x72, 0x6F, 0x72, 0x00, 0x00, 0x84, 0x02, 0x47, 0x65, 0x74, 0x4E, 0x61, 0x74,
		0x69, 0x76, 0x65, 0x53, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x49, 0x6E, 0x66, 0x6F, 0x00, 0xBC, 0x03, 0x4C, 0x6F, 0x61, 0x64, 0x4C, 0x69, 0x62, 0x72, 0x61, 0x72, 0x79, 0x57, 0x00, 0x00, 0xAE, 0x02, 0x47, 0x65, 0x74, 0x50, 0x72, 0x6F, 0x63, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x00, 0x00, 0x60, 0x01, 0x45, 0x78, 0x69, 0x74, 0x50, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x00, 0x1A, 0x02,
		0x47, 0x65, 0x74, 0x43, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x50, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x49, 0x64, 0x00, 0xA2, 0x01, 0x46, 0x6C, 0x75, 0x73, 0x68, 0x49, 0x6E, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x43, 0x61, 0x63, 0x68, 0x65, 0x00, 0xDD, 0x05, 0x57, 0x61, 0x69, 0x74, 0x4E, 0x61, 0x6D, 0x65, 0x64, 0x50, 0x69, 0x70, 0x65, 0x57, 0x00, 0x00, 0x4B, 0x45,
		0x52, 0x4E, 0x45, 0x4C, 0x33, 0x32, 0x2E, 0x64, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x08, 0x10, 0x00, 0x00, 0x19, 0x17, 0x00, 0x00, 0x64, 0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x18, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
		0x09, 0x04, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x60, 0x40, 0x00, 0x00, 0x7D, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x3F, 0x78, 0x6D, 0x6C, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E, 0x3D, 0x27, 0x31, 0x2E, 0x30, 0x27, 0x20, 0x65, 0x6E, 0x63, 0x6F, 0x64, 0x69, 0x6E, 0x67, 0x3D, 0x27, 0x55, 0x54,
		0x46, 0x2D, 0x38, 0x27, 0x20, 0x73, 0x74, 0x61, 0x6E, 0x64, 0x61, 0x6C, 0x6F, 0x6E, 0x65, 0x3D, 0x27, 0x79, 0x65, 0x73, 0x27, 0x3F, 0x3E, 0x0D, 0x0A, 0x3C, 0x61, 0x73, 0x73, 0x65, 0x6D, 0x62, 0x6C, 0x79, 0x20, 0x78, 0x6D, 0x6C, 0x6E, 0x73, 0x3D, 0x27, 0x75, 0x72, 0x6E, 0x3A, 0x73, 0x63, 0x68, 0x65, 0x6D, 0x61, 0x73, 0x2D, 0x6D, 0x69, 0x63, 0x72, 0x6F, 0x73, 0x6F, 0x66, 0x74, 0x2D,
		0x63, 0x6F, 0x6D, 0x3A, 0x61, 0x73, 0x6D, 0x2E, 0x76, 0x31, 0x27, 0x20, 0x6D, 0x61, 0x6E, 0x69, 0x66, 0x65, 0x73, 0x74, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E, 0x3D, 0x27, 0x31, 0x2E, 0x30, 0x27, 0x3E, 0x0D, 0x0A, 0x20, 0x20, 0x3C, 0x74, 0x72, 0x75, 0x73, 0x74, 0x49, 0x6E, 0x66, 0x6F, 0x20, 0x78, 0x6D, 0x6C, 0x6E, 0x73, 0x3D, 0x22, 0x75, 0x72, 0x6E, 0x3A, 0x73, 0x63, 0x68, 0x65,
		0x6D, 0x61, 0x73, 0x2D, 0x6D, 0x69, 0x63, 0x72, 0x6F, 0x73, 0x6F, 0x66, 0x74, 0x2D, 0x63, 0x6F, 0x6D, 0x3A, 0x61, 0x73, 0x6D, 0x2E, 0x76, 0x33, 0x22, 0x3E, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x3C, 0x73, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x3E, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3C, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x65, 0x64, 0x50, 0x72, 0x69, 0x76,
		0x69, 0x6C, 0x65, 0x67, 0x65, 0x73, 0x3E, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3C, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x65, 0x64, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74, 0x69, 0x6F, 0x6E, 0x4C, 0x65, 0x76, 0x65, 0x6C, 0x20, 0x6C, 0x65, 0x76, 0x65, 0x6C, 0x3D, 0x27, 0x61, 0x73, 0x49, 0x6E, 0x76, 0x6F, 0x6B, 0x65, 0x72, 0x27, 0x20, 0x75, 0x69, 0x41, 0x63,
		0x63, 0x65, 0x73, 0x73, 0x3D, 0x27, 0x66, 0x61, 0x6C, 0x73, 0x65, 0x27, 0x20, 0x2F, 0x3E, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3C, 0x2F, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x65, 0x64, 0x50, 0x72, 0x69, 0x76, 0x69, 0x6C, 0x65, 0x67, 0x65, 0x73, 0x3E, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x3C, 0x2F, 0x73, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x3E, 0x0D, 0x0A,
		0x20, 0x20, 0x3C, 0x2F, 0x74, 0x72, 0x75, 0x73, 0x74, 0x49, 0x6E, 0x66, 0x6F, 0x3E, 0x0D, 0x0A, 0x3C, 0x2F, 0x61, 0x73, 0x73, 0x65, 0x6D, 0x62, 0x6C, 0x79, 0x3E, 0x0D, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
#elif _M_IX86
	static const BYTE LibraryFileData[] = {
		0x4D, 0x5A, 0x90, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0, 0x00, 0x00, 0x00,
		0x0E, 0x1F, 0xBA, 0x0E, 0x00, 0xB4, 0x09, 0xCD, 0x21, 0xB8, 0x01, 0x4C, 0xCD, 0x21, 0x54, 0x68, 0x69, 0x73, 0x20, 0x70, 0x72, 0x6F, 0x67, 0x72, 0x61, 0x6D, 0x20, 0x63, 0x61, 0x6E, 0x6E, 0x6F, 0x74, 0x20, 0x62, 0x65, 0x20, 0x72, 0x75, 0x6E, 0x20, 0x69, 0x6E, 0x20, 0x44, 0x4F, 0x53, 0x20, 0x6D, 0x6F, 0x64, 0x65, 0x2E, 0x0D, 0x0D, 0x0A, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x0E, 0x33, 0x1F, 0xCB, 0x4A, 0x52, 0x71, 0x98, 0x4A, 0x52, 0x71, 0x98, 0x4A, 0x52, 0x71, 0x98, 0x68, 0x32, 0x70, 0x99, 0x49, 0x52, 0x71, 0x98, 0x4A, 0x52, 0x70, 0x98, 0x5A, 0x52, 0x71, 0x98, 0xE9, 0x31, 0x78, 0x99, 0x4B, 0x52, 0x71, 0x98, 0xE9, 0x31, 0x71, 0x99, 0x4B, 0x52, 0x71, 0x98, 0xE9, 0x31, 0x8E, 0x98, 0x4B, 0x52, 0x71, 0x98, 0xE9, 0x31, 0x73, 0x99, 0x4B, 0x52, 0x71, 0x98,
		0x52, 0x69, 0x63, 0x68, 0x4A, 0x52, 0x71, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x45, 0x00, 0x00, 0x4C, 0x01, 0x04, 0x00, 0x06, 0xC5, 0xAF, 0x59, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x22, 0x21, 0x0B, 0x01, 0x0E, 0x0B, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00,
		0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x10, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x40, 0x05, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x70, 0x22, 0x00, 0x00, 0x4C, 0x00, 0x00, 0x00, 0xFC, 0x23, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0xE0, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2E, 0x74, 0x65, 0x78, 0x74, 0x00, 0x00, 0x00, 0x6D, 0x08, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x60, 0x2E, 0x72, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0xA4, 0x05, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00,
		0x00, 0x06, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x40, 0x2E, 0x72, 0x73, 0x72, 0x63, 0x00, 0x00, 0x00, 0xE0, 0x01, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x40,
		0x2E, 0x72, 0x65, 0x6C, 0x6F, 0x63, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x55, 0x8B, 0xEC, 0x33, 0xC0, 0x40, 0x5D, 0xC2, 0x0C, 0x00, 0x55, 0x8B, 0xEC, 0x81, 0xEC, 0x3C, 0x01, 0x00, 0x00, 0x8D, 0x85, 0x04, 0xFF, 0xFF, 0xFF, 0x50, 0xFF, 0x15, 0x24, 0x20, 0x00, 0x10, 0x8B, 0x85, 0x08, 0xFF, 0xFF, 0xFF, 0x89, 0x45, 0xDC, 0xFF, 0x15, 0x34, 0x20, 0x00, 0x10, 0x89, 0x85, 0x4C, 0xFF, 0xFF, 0xFF, 0x68, 0x50, 0x20, 0x00, 0x10, 0xFF, 0x15, 0x28, 0x20, 0x00, 0x10,
		0x89, 0x45, 0xE4, 0x83, 0x7D, 0xE4, 0x00, 0x75, 0x0D, 0xFF, 0x15, 0x20, 0x20, 0x00, 0x10, 0x50, 0xFF, 0x15, 0x30, 0x20, 0x00, 0x10, 0x68, 0x6C, 0x20, 0x00, 0x10, 0xFF, 0x75, 0xE4, 0xFF, 0x15, 0x2C, 0x20, 0x00, 0x10, 0x89, 0x45, 0xEC, 0x68, 0x78, 0x20, 0x00, 0x10, 0xFF, 0x75, 0xE4, 0xFF, 0x15, 0x2C, 0x20, 0x00, 0x10, 0x89, 0x45, 0xE8, 0x68, 0x88, 0x20, 0x00, 0x10, 0xFF, 0x75, 0xE4,
		0xFF, 0x15, 0x2C, 0x20, 0x00, 0x10, 0x89, 0x85, 0x44, 0xFF, 0xFF, 0xFF, 0x68, 0x94, 0x20, 0x00, 0x10, 0xFF, 0x75, 0xE4, 0xFF, 0x15, 0x2C, 0x20, 0x00, 0x10, 0x89, 0x85, 0x40, 0xFF, 0xFF, 0xFF, 0x68, 0xA0, 0x20, 0x00, 0x10, 0xFF, 0x75, 0xE4, 0xFF, 0x15, 0x2C, 0x20, 0x00, 0x10, 0x89, 0x85, 0x3C, 0xFF, 0xFF, 0xFF, 0x68, 0xAC, 0x20, 0x00, 0x10, 0xFF, 0x75, 0xE4, 0xFF, 0x15, 0x2C, 0x20,
		0x00, 0x10, 0x89, 0x85, 0x38, 0xFF, 0xFF, 0xFF, 0x68, 0xB8, 0x20, 0x00, 0x10, 0xFF, 0x75, 0xE4, 0xFF, 0x15, 0x2C, 0x20, 0x00, 0x10, 0x89, 0x85, 0x34, 0xFF, 0xFF, 0xFF, 0x68, 0xCC, 0x20, 0x00, 0x10, 0xFF, 0x75, 0xE4, 0xFF, 0x15, 0x2C, 0x20, 0x00, 0x10, 0x89, 0x85, 0x30, 0xFF, 0xFF, 0xFF, 0x68, 0xE0, 0x20, 0x00, 0x10, 0xFF, 0x75, 0xE4, 0xFF, 0x15, 0x2C, 0x20, 0x00, 0x10, 0x89, 0x85,
		0x2C, 0xFF, 0xFF, 0xFF, 0x8D, 0x85, 0x5C, 0xFF, 0xFF, 0xFF, 0x50, 0x68, 0x0A, 0x10, 0x00, 0x10, 0x6A, 0x06, 0xFF, 0x15, 0x0C, 0x20, 0x00, 0x10, 0x85, 0xC0, 0x75, 0x07, 0xFF, 0x55, 0xE8, 0x50, 0xFF, 0x55, 0xEC, 0x6A, 0x20, 0x8D, 0x85, 0xC4, 0xFE, 0xFF, 0xFF, 0x50, 0x68, 0xE8, 0x20, 0x00, 0x10, 0xFF, 0x15, 0x18, 0x20, 0x00, 0x10, 0x83, 0xF8, 0x1F, 0x74, 0x08, 0x68, 0x0D, 0x07, 0x00,
		0x00, 0xFF, 0x55, 0xEC, 0x6A, 0xFF, 0x8D, 0x85, 0xC4, 0xFE, 0xFF, 0xFF, 0x50, 0xFF, 0x15, 0x3C, 0x20, 0x00, 0x10, 0x85, 0xC0, 0x75, 0x07, 0xFF, 0x55, 0xE8, 0x50, 0xFF, 0x55, 0xEC, 0x6A, 0x00, 0x6A, 0x00, 0x6A, 0x03, 0x6A, 0x00, 0x6A, 0x00, 0x68, 0x00, 0x00, 0x00, 0x40, 0x8D, 0x85, 0xC4, 0xFE, 0xFF, 0xFF, 0x50, 0xFF, 0x15, 0x1C, 0x20, 0x00, 0x10, 0x89, 0x85, 0x78, 0xFF, 0xFF, 0xFF,
		0x83, 0xBD, 0x78, 0xFF, 0xFF, 0xFF, 0xFF, 0x75, 0x07, 0xFF, 0x55, 0xE8, 0x50, 0xFF, 0x55, 0xEC, 0x8B, 0x45, 0xDC, 0x05, 0x12, 0x05, 0x00, 0x00, 0x8B, 0x4D, 0xDC, 0x49, 0xF7, 0xD1, 0x23, 0xC1, 0x89, 0x45, 0xF0, 0x6A, 0x04, 0x68, 0x00, 0x30, 0x00, 0x00, 0xFF, 0x75, 0xF0, 0x6A, 0x00, 0xFF, 0x15, 0x10, 0x20, 0x00, 0x10, 0x89, 0x45, 0xF4, 0x83, 0x7D, 0xF4, 0x00, 0x75, 0x07, 0xFF, 0x55,
		0xE8, 0x50, 0xFF, 0x55, 0xEC, 0x8B, 0x45, 0xF0, 0xD1, 0xE8, 0x50, 0xFF, 0x75, 0xF4, 0xFF, 0xB5, 0x5C, 0xFF, 0xFF, 0xFF, 0xFF, 0x15, 0x14, 0x20, 0x00, 0x10, 0xD1, 0xE0, 0x89, 0x45, 0xF8, 0x8B, 0x45, 0xF8, 0x3B, 0x45, 0xF0, 0x73, 0x0C, 0x8B, 0x45, 0xF8, 0x40, 0x40, 0x89, 0x45, 0xF8, 0xEB, 0x73, 0xEB, 0x6C, 0x83, 0x7D, 0xF8, 0x00, 0x74, 0x5F, 0x8B, 0x45, 0xF8, 0x05, 0x08, 0x02, 0x00,
		0x00, 0x89, 0x45, 0xF8, 0x68, 0x00, 0x80, 0x00, 0x00, 0x6A, 0x00, 0xFF, 0x75, 0xF4, 0xFF, 0x15, 0x04, 0x20, 0x00, 0x10, 0x8B, 0x45, 0xF8, 0x05, 0x49, 0x02, 0x00, 0x00, 0x83, 0xE0, 0xC0, 0x8B, 0x4D, 0xDC, 0x8D, 0x84, 0x08, 0xD2, 0x00, 0x00, 0x00, 0x8B, 0x4D, 0xDC, 0x49, 0xF7, 0xD1, 0x23, 0xC1, 0x89, 0x45, 0xF0, 0x6A, 0x04, 0x68, 0x00, 0x30, 0x00, 0x00, 0xFF, 0x75, 0xF0, 0x6A, 0x00,
		0xFF, 0x15, 0x10, 0x20, 0x00, 0x10, 0x89, 0x45, 0xF4, 0x83, 0x7D, 0xF4, 0x00, 0x75, 0x07, 0xFF, 0x55, 0xE8, 0x50, 0xFF, 0x55, 0xEC, 0xEB, 0x07, 0xFF, 0x55, 0xE8, 0x50, 0xFF, 0x55, 0xEC, 0xE9, 0x61, 0xFF, 0xFF, 0xFF, 0x8B, 0x45, 0xF0, 0x2B, 0x45, 0xF8, 0xD1, 0xE8, 0x50, 0x8B, 0x45, 0xF4, 0x03, 0x45, 0xF8, 0x50, 0x68, 0x08, 0x21, 0x00, 0x10, 0xFF, 0x15, 0x18, 0x20, 0x00, 0x10, 0xD1,
		0xE0, 0x89, 0x45, 0xE0, 0x8B, 0x45, 0xF0, 0x2B, 0x45, 0xF8, 0x39, 0x45, 0xE0, 0x73, 0x12, 0x8B, 0x45, 0xE0, 0x40, 0x40, 0x89, 0x45, 0xE0, 0xE9, 0xD2, 0x00, 0x00, 0x00, 0xE9, 0xC8, 0x00, 0x00, 0x00, 0x83, 0x7D, 0xE0, 0x00, 0x0F, 0x84, 0xB7, 0x00, 0x00, 0x00, 0x8B, 0x45, 0xE0, 0x8B, 0x4D, 0xF8, 0x8D, 0x44, 0x01, 0x3F, 0x83, 0xE0, 0xC0, 0x8B, 0x4D, 0xDC, 0x8D, 0x84, 0x08, 0xD2, 0x00,
		0x00, 0x00, 0x8B, 0x4D, 0xDC, 0x49, 0xF7, 0xD1, 0x23, 0xC1, 0x89, 0x45, 0xF0, 0x6A, 0x04, 0x68, 0x00, 0x30, 0x00, 0x00, 0xFF, 0x75, 0xF0, 0x6A, 0x00, 0xFF, 0x15, 0x10, 0x20, 0x00, 0x10, 0x89, 0x85, 0x6C, 0xFF, 0xFF, 0xFF, 0x83, 0xBD, 0x6C, 0xFF, 0xFF, 0xFF, 0x00, 0x75, 0x07, 0xFF, 0x55, 0xE8, 0x50, 0xFF, 0x55, 0xEC, 0x8B, 0x85, 0x6C, 0xFF, 0xFF, 0xFF, 0x89, 0x85, 0x70, 0xFF, 0xFF,
		0xFF, 0x8B, 0x45, 0xF4, 0x89, 0x45, 0xD8, 0x8B, 0x45, 0xD8, 0x03, 0x45, 0xF8, 0x89, 0x85, 0x58, 0xFF, 0xFF, 0xFF, 0xEB, 0x16, 0x8B, 0x45, 0xD8, 0x40, 0x40, 0x89, 0x45, 0xD8, 0x8B, 0x85, 0x70, 0xFF, 0xFF, 0xFF, 0x40, 0x40, 0x89, 0x85, 0x70, 0xFF, 0xFF, 0xFF, 0x8B, 0x45, 0xD8, 0x3B, 0x85, 0x58, 0xFF, 0xFF, 0xFF, 0x74, 0x11, 0x8B, 0x85, 0x70, 0xFF, 0xFF, 0xFF, 0x8B, 0x4D, 0xD8, 0x66,
		0x8B, 0x09, 0x66, 0x89, 0x08, 0xEB, 0xCE, 0x68, 0x00, 0x80, 0x00, 0x00, 0x6A, 0x00, 0xFF, 0x75, 0xF4, 0xFF, 0x15, 0x04, 0x20, 0x00, 0x10, 0x8B, 0x85, 0x6C, 0xFF, 0xFF, 0xFF, 0x89, 0x45, 0xF4, 0xEB, 0x07, 0xFF, 0x55, 0xE8, 0x50, 0xFF, 0x55, 0xEC, 0xE9, 0xF6, 0xFE, 0xFF, 0xFF, 0x8B, 0x45, 0xE0, 0x8B, 0x4D, 0xF8, 0x8D, 0x44, 0x01, 0x3F, 0x83, 0xE0, 0xC0, 0x8B, 0x4D, 0xF0, 0x2B, 0xC8,
		0x81, 0xF9, 0xD3, 0x00, 0x00, 0x00, 0x0F, 0x83, 0xB8, 0x00, 0x00, 0x00, 0x8B, 0x45, 0xE0, 0x8B, 0x4D, 0xF8, 0x8D, 0x44, 0x01, 0x3F, 0x83, 0xE0, 0xC0, 0x8B, 0x4D, 0xDC, 0x8D, 0x84, 0x08, 0xD2, 0x00, 0x00, 0x00, 0x8B, 0x4D, 0xDC, 0x49, 0xF7, 0xD1, 0x23, 0xC1, 0x89, 0x45, 0xF0, 0x6A, 0x04, 0x68, 0x00, 0x30, 0x00, 0x00, 0xFF, 0x75, 0xF0, 0x6A, 0x00, 0xFF, 0x15, 0x10, 0x20, 0x00, 0x10,
		0x89, 0x85, 0x64, 0xFF, 0xFF, 0xFF, 0x83, 0xBD, 0x64, 0xFF, 0xFF, 0xFF, 0x00, 0x75, 0x07, 0xFF, 0x55, 0xE8, 0x50, 0xFF, 0x55, 0xEC, 0x8B, 0x85, 0x64, 0xFF, 0xFF, 0xFF, 0x89, 0x85, 0x68, 0xFF, 0xFF, 0xFF, 0x8B, 0x45, 0xF4, 0x89, 0x45, 0xD4, 0x8B, 0x45, 0xD4, 0x03, 0x45, 0xF8, 0x03, 0x45, 0xE0, 0x89, 0x85, 0x54, 0xFF, 0xFF, 0xFF, 0xEB, 0x16, 0x8B, 0x45, 0xD4, 0x40, 0x40, 0x89, 0x45,
		0xD4, 0x8B, 0x85, 0x68, 0xFF, 0xFF, 0xFF, 0x40, 0x40, 0x89, 0x85, 0x68, 0xFF, 0xFF, 0xFF, 0x8B, 0x45, 0xD4, 0x3B, 0x85, 0x54, 0xFF, 0xFF, 0xFF, 0x74, 0x11, 0x8B, 0x85, 0x68, 0xFF, 0xFF, 0xFF, 0x8B, 0x4D, 0xD4, 0x66, 0x8B, 0x09, 0x66, 0x89, 0x08, 0xEB, 0xCE, 0x68, 0x00, 0x80, 0x00, 0x00, 0x6A, 0x00, 0xFF, 0x75, 0xF4, 0xFF, 0x15, 0x04, 0x20, 0x00, 0x10, 0x8B, 0x85, 0x64, 0xFF, 0xFF,
		0xFF, 0x89, 0x45, 0xF4, 0x8B, 0x45, 0xE0, 0x8B, 0x4D, 0xF8, 0x8D, 0x44, 0x01, 0x3F, 0x83, 0xE0, 0xC0, 0x03, 0x45, 0xF4, 0x89, 0x85, 0x60, 0xFF, 0xFF, 0xFF, 0xC7, 0x45, 0xD0, 0x28, 0x21, 0x00, 0x10, 0x8B, 0x45, 0xD0, 0x05, 0xD3, 0x00, 0x00, 0x00, 0x89, 0x85, 0x50, 0xFF, 0xFF, 0xFF, 0xEB, 0x14, 0x8B, 0x45, 0xD0, 0x40, 0x89, 0x45, 0xD0, 0x8B, 0x85, 0x60, 0xFF, 0xFF, 0xFF, 0x40, 0x89,
		0x85, 0x60, 0xFF, 0xFF, 0xFF, 0x8B, 0x45, 0xD0, 0x3B, 0x85, 0x50, 0xFF, 0xFF, 0xFF, 0x74, 0x0F, 0x8B, 0x85, 0x60, 0xFF, 0xFF, 0xFF, 0x8B, 0x4D, 0xD0, 0x8A, 0x09, 0x88, 0x08, 0xEB, 0xD2, 0x8B, 0x45, 0xF4, 0x89, 0x85, 0x48, 0xFF, 0xFF, 0xFF, 0x8B, 0x45, 0xF4, 0x03, 0x45, 0xF8, 0x89, 0x85, 0x74, 0xFF, 0xFF, 0xFF, 0x8B, 0x45, 0xE0, 0x8B, 0x4D, 0xF8, 0x8D, 0x44, 0x01, 0x3F, 0x83, 0xE0,
		0xC0, 0x03, 0x45, 0xF4, 0x89, 0x45, 0xFC, 0x83, 0x65, 0xCC, 0x00, 0xEB, 0x07, 0x8B, 0x45, 0xCC, 0x40, 0x89, 0x45, 0xCC, 0x83, 0x7D, 0xCC, 0x04, 0x74, 0x15, 0x8B, 0x45, 0xFC, 0x03, 0x45, 0xCC, 0x8B, 0x4D, 0xCC, 0x8A, 0x8C, 0x0D, 0x78, 0xFF, 0xFF, 0xFF, 0x88, 0x48, 0x5D, 0xEB, 0xDE, 0x83, 0x65, 0xC8, 0x00, 0xEB, 0x07, 0x8B, 0x45, 0xC8, 0x40, 0x89, 0x45, 0xC8, 0x83, 0x7D, 0xC8, 0x04,
		0x74, 0x15, 0x8B, 0x45, 0xFC, 0x03, 0x45, 0xC8, 0x8B, 0x4D, 0xC8, 0x8A, 0x8C, 0x0D, 0x78, 0xFF, 0xFF, 0xFF, 0x88, 0x48, 0x7D, 0xEB, 0xDE, 0x83, 0x65, 0xC4, 0x00, 0xEB, 0x07, 0x8B, 0x45, 0xC4, 0x40, 0x89, 0x45, 0xC4, 0x83, 0x7D, 0xC4, 0x04, 0x74, 0x18, 0x8B, 0x45, 0xFC, 0x03, 0x45, 0xC4, 0x8B, 0x4D, 0xC4, 0x8A, 0x8C, 0x0D, 0x78, 0xFF, 0xFF, 0xFF, 0x88, 0x88, 0x89, 0x00, 0x00, 0x00,
		0xEB, 0xDB, 0x83, 0x65, 0xC0, 0x00, 0xEB, 0x07, 0x8B, 0x45, 0xC0, 0x40, 0x89, 0x45, 0xC0, 0x83, 0x7D, 0xC0, 0x04, 0x74, 0x15, 0x8B, 0x45, 0xFC, 0x03, 0x45, 0xC0, 0x8B, 0x4D, 0xC0, 0x8A, 0x8C, 0x0D, 0x4C, 0xFF, 0xFF, 0xFF, 0x88, 0x48, 0x16, 0xEB, 0xDE, 0x83, 0x65, 0xBC, 0x00, 0xEB, 0x07, 0x8B, 0x45, 0xBC, 0x40, 0x89, 0x45, 0xBC, 0x83, 0x7D, 0xBC, 0x04, 0x74, 0x15, 0x8B, 0x45, 0xFC,
		0x03, 0x45, 0xBC, 0x8B, 0x4D, 0xBC, 0x8A, 0x8C, 0x0D, 0x5C, 0xFF, 0xFF, 0xFF, 0x88, 0x48, 0x0A, 0xEB, 0xDE, 0x83, 0x65, 0xB8, 0x00, 0xEB, 0x07, 0x8B, 0x45, 0xB8, 0x40, 0x89, 0x45, 0xB8, 0x83, 0x7D, 0xB8, 0x04, 0x74, 0x15, 0x8B, 0x45, 0xFC, 0x03, 0x45, 0xB8, 0x8B, 0x4D, 0xB8, 0x8A, 0x8C, 0x0D, 0x48, 0xFF, 0xFF, 0xFF, 0x88, 0x48, 0x30, 0xEB, 0xDE, 0x83, 0x65, 0xB4, 0x00, 0xEB, 0x07,
		0x8B, 0x45, 0xB4, 0x40, 0x89, 0x45, 0xB4, 0x83, 0x7D, 0xB4, 0x04, 0x74, 0x15, 0x8B, 0x45, 0xFC, 0x03, 0x45, 0xB4, 0x8B, 0x4D, 0xB4, 0x8A, 0x8C, 0x0D, 0x74, 0xFF, 0xFF, 0xFF, 0x88, 0x48, 0x3B, 0xEB, 0xDE, 0x83, 0x65, 0xB0, 0x00, 0xEB, 0x07, 0x8B, 0x45, 0xB0, 0x40, 0x89, 0x45, 0xB0, 0x83, 0x7D, 0xB0, 0x04, 0x74, 0x18, 0x8B, 0x45, 0xFC, 0x03, 0x45, 0xB0, 0x8B, 0x4D, 0xB0, 0x8A, 0x8C,
		0x0D, 0x74, 0xFF, 0xFF, 0xFF, 0x88, 0x88, 0x95, 0x00, 0x00, 0x00, 0xEB, 0xDB, 0x83, 0x65, 0xAC, 0x00, 0xEB, 0x07, 0x8B, 0x45, 0xAC, 0x40, 0x89, 0x45, 0xAC, 0x83, 0x7D, 0xAC, 0x04, 0x74, 0x18, 0x8B, 0x45, 0xFC, 0x03, 0x45, 0xAC, 0x8B, 0x4D, 0xAC, 0x8A, 0x8C, 0x0D, 0x74, 0xFF, 0xFF, 0xFF, 0x88, 0x88, 0xA6, 0x00, 0x00, 0x00, 0xEB, 0xDB, 0x83, 0x65, 0xA8, 0x00, 0xEB, 0x07, 0x8B, 0x45,
		0xA8, 0x40, 0x89, 0x45, 0xA8, 0x83, 0x7D, 0xA8, 0x04, 0x74, 0x18, 0x8B, 0x45, 0xFC, 0x03, 0x45, 0xA8, 0x8B, 0x4D, 0xA8, 0x8A, 0x8C, 0x0D, 0x74, 0xFF, 0xFF, 0xFF, 0x88, 0x88, 0xB8, 0x00, 0x00, 0x00, 0xEB, 0xDB, 0x83, 0x65, 0xA4, 0x00, 0xEB, 0x07, 0x8B, 0x45, 0xA4, 0x40, 0x89, 0x45, 0xA4, 0x83, 0x7D, 0xA4, 0x04, 0x74, 0x12, 0x8B, 0x45, 0xFC, 0x03, 0x45, 0xA4, 0x8B, 0x4D, 0xA4, 0x8A,
		0x4C, 0x0D, 0xEC, 0x88, 0x48, 0x1D, 0xEB, 0xE1, 0x83, 0x65, 0xA0, 0x00, 0xEB, 0x07, 0x8B, 0x45, 0xA0, 0x40, 0x89, 0x45, 0xA0, 0x83, 0x7D, 0xA0, 0x04, 0x74, 0x15, 0x8B, 0x45, 0xFC, 0x03, 0x45, 0xA0, 0x8B, 0x4D, 0xA0, 0x8A, 0x4C, 0x0D, 0xEC, 0x88, 0x88, 0xC4, 0x00, 0x00, 0x00, 0xEB, 0xDE, 0x83, 0x65, 0x9C, 0x00, 0xEB, 0x07, 0x8B, 0x45, 0x9C, 0x40, 0x89, 0x45, 0x9C, 0x83, 0x7D, 0x9C,
		0x04, 0x74, 0x12, 0x8B, 0x45, 0xFC, 0x03, 0x45, 0x9C, 0x8B, 0x4D, 0x9C, 0x8A, 0x4C, 0x0D, 0xE8, 0x88, 0x48, 0x47, 0xEB, 0xE1, 0x83, 0x65, 0x98, 0x00, 0xEB, 0x07, 0x8B, 0x45, 0x98, 0x40, 0x89, 0x45, 0x98, 0x83, 0x7D, 0x98, 0x04, 0x74, 0x12, 0x8B, 0x45, 0xFC, 0x03, 0x45, 0x98, 0x8B, 0x4D, 0x98, 0x8A, 0x4C, 0x0D, 0xE8, 0x88, 0x48, 0x73, 0xEB, 0xE1, 0x83, 0x65, 0x94, 0x00, 0xEB, 0x07,
		0x8B, 0x45, 0x94, 0x40, 0x89, 0x45, 0x94, 0x83, 0x7D, 0x94, 0x04, 0x74, 0x15, 0x8B, 0x45, 0xFC, 0x03, 0x45, 0x94, 0x8B, 0x4D, 0x94, 0x8A, 0x8C, 0x0D, 0x44, 0xFF, 0xFF, 0xFF, 0x88, 0x48, 0x0F, 0xEB, 0xDE, 0x83, 0x65, 0x90, 0x00, 0xEB, 0x07, 0x8B, 0x45, 0x90, 0x40, 0x89, 0x45, 0x90, 0x83, 0x7D, 0x90, 0x04, 0x74, 0x15, 0x8B, 0x45, 0xFC, 0x03, 0x45, 0x90, 0x8B, 0x4D, 0x90, 0x8A, 0x8C,
		0x0D, 0x40, 0xFF, 0xFF, 0xFF, 0x88, 0x48, 0x22, 0xEB, 0xDE, 0x83, 0x65, 0x8C, 0x00, 0xEB, 0x07, 0x8B, 0x45, 0x8C, 0x40, 0x89, 0x45, 0x8C, 0x83, 0x7D, 0x8C, 0x04, 0x74, 0x18, 0x8B, 0x45, 0xFC, 0x03, 0x45, 0x8C, 0x8B, 0x4D, 0x8C, 0x8A, 0x8C, 0x0D, 0x3C, 0xFF, 0xFF, 0xFF, 0x88, 0x88, 0x8E, 0x00, 0x00, 0x00, 0xEB, 0xDB, 0x83, 0x65, 0x88, 0x00, 0xEB, 0x07, 0x8B, 0x45, 0x88, 0x40, 0x89,
		0x45, 0x88, 0x83, 0x7D, 0x88, 0x04, 0x74, 0x15, 0x8B, 0x45, 0xFC, 0x03, 0x45, 0x88, 0x8B, 0x4D, 0x88, 0x8A, 0x8C, 0x0D, 0x38, 0xFF, 0xFF, 0xFF, 0x88, 0x48, 0x62, 0xEB, 0xDE, 0x83, 0x65, 0x84, 0x00, 0xEB, 0x07, 0x8B, 0x45, 0x84, 0x40, 0x89, 0x45, 0x84, 0x83, 0x7D, 0x84, 0x04, 0x74, 0x18, 0x8B, 0x45, 0xFC, 0x03, 0x45, 0x84, 0x8B, 0x4D, 0x84, 0x8A, 0x8C, 0x0D, 0x34, 0xFF, 0xFF, 0xFF,
		0x88, 0x88, 0x82, 0x00, 0x00, 0x00, 0xEB, 0xDB, 0x83, 0x65, 0x80, 0x00, 0xEB, 0x07, 0x8B, 0x45, 0x80, 0x40, 0x89, 0x45, 0x80, 0x83, 0x7D, 0x80, 0x04, 0x74, 0x15, 0x8B, 0x45, 0xFC, 0x03, 0x45, 0x80, 0x8B, 0x4D, 0x80, 0x8A, 0x8C, 0x0D, 0x30, 0xFF, 0xFF, 0xFF, 0x88, 0x48, 0x27, 0xEB, 0xDE, 0x83, 0xA5, 0x7C, 0xFF, 0xFF, 0xFF, 0x00, 0xEB, 0x0D, 0x8B, 0x85, 0x7C, 0xFF, 0xFF, 0xFF, 0x40,
		0x89, 0x85, 0x7C, 0xFF, 0xFF, 0xFF, 0x83, 0xBD, 0x7C, 0xFF, 0xFF, 0xFF, 0x04, 0x74, 0x1E, 0x8B, 0x45, 0xFC, 0x03, 0x85, 0x7C, 0xFF, 0xFF, 0xFF, 0x8B, 0x8D, 0x7C, 0xFF, 0xFF, 0xFF, 0x8A, 0x8C, 0x0D, 0x2C, 0xFF, 0xFF, 0xFF, 0x88, 0x88, 0xA1, 0x00, 0x00, 0x00, 0xEB, 0xCC, 0x8D, 0x85, 0x28, 0xFF, 0xFF, 0xFF, 0x50, 0x6A, 0x20, 0xFF, 0x75, 0xF0, 0xFF, 0x75, 0xF4, 0xFF, 0x15, 0x00, 0x20,
		0x00, 0x10, 0x85, 0xC0, 0x74, 0x17, 0xFF, 0x75, 0xF0, 0xFF, 0x75, 0xF4, 0xFF, 0x15, 0x08, 0x20, 0x00, 0x10, 0x50, 0xFF, 0x15, 0x38, 0x20, 0x00, 0x10, 0x85, 0xC0, 0x75, 0x07, 0xFF, 0x55, 0xE8, 0x50, 0xFF, 0x55, 0xEC, 0xFF, 0x55, 0xFC, 0x8B, 0xE5, 0x5D, 0xC2, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x68, 0x24, 0x00, 0x00, 0x7A, 0x24, 0x00, 0x00, 0x88, 0x24, 0x00, 0x00, 0x9C, 0x24, 0x00, 0x00, 0xB2, 0x24, 0x00, 0x00, 0xC2, 0x24, 0x00, 0x00, 0xD8, 0x24, 0x00, 0x00, 0xF2, 0x24, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x10, 0x25, 0x00, 0x00, 0x26, 0x25, 0x00, 0x00, 0x36, 0x25, 0x00, 0x00, 0x48, 0x25, 0x00, 0x00, 0x56, 0x25, 0x00, 0x00, 0x6C, 0x25, 0x00, 0x00, 0x84, 0x25, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4B, 0x00, 0x65, 0x00, 0x72, 0x00, 0x6E, 0x00, 0x65, 0x00, 0x6C, 0x00, 0x33, 0x00, 0x32, 0x00, 0x2E, 0x00, 0x64, 0x00, 0x6C, 0x00, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x78, 0x69, 0x74, 0x50, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x00, 0x47, 0x65, 0x74, 0x4C, 0x61, 0x73, 0x74, 0x45,
		0x72, 0x72, 0x6F, 0x72, 0x00, 0x00, 0x00, 0x00, 0x46, 0x72, 0x65, 0x65, 0x4C, 0x69, 0x62, 0x72, 0x61, 0x72, 0x79, 0x00, 0x44, 0x65, 0x6C, 0x65, 0x74, 0x65, 0x46, 0x69, 0x6C, 0x65, 0x57, 0x00, 0x43, 0x6C, 0x6F, 0x73, 0x65, 0x48, 0x61, 0x6E, 0x64, 0x6C, 0x65, 0x00, 0x57, 0x72, 0x69, 0x74, 0x65, 0x46, 0x69, 0x6C, 0x65, 0x00, 0x00, 0x00, 0x46, 0x6C, 0x75, 0x73, 0x68, 0x46, 0x69, 0x6C,
		0x65, 0x42, 0x75, 0x66, 0x66, 0x65, 0x72, 0x73, 0x00, 0x00, 0x00, 0x00, 0x47, 0x65, 0x74, 0x46, 0x69, 0x6C, 0x65, 0x41, 0x74, 0x74, 0x72, 0x69, 0x62, 0x75, 0x74, 0x65, 0x73, 0x57, 0x00, 0x00, 0x53, 0x6C, 0x65, 0x65, 0x70, 0x00, 0x00, 0x00, 0x53, 0x00, 0x4E, 0x00, 0x57, 0x00, 0x55, 0x00, 0x53, 0x00, 0x44, 0x00, 0x50, 0x00, 0x55, 0x00, 0x49, 0x00, 0x5F, 0x00, 0x50, 0x00, 0x49, 0x00,
		0x50, 0x00, 0x45, 0x00, 0x00, 0x00, 0x00, 0x00, 0x53, 0x00, 0x4E, 0x00, 0x57, 0x00, 0x55, 0x00, 0x53, 0x00, 0x44, 0x00, 0x50, 0x00, 0x55, 0x00, 0x49, 0x00, 0x5F, 0x00, 0x46, 0x00, 0x49, 0x00, 0x4C, 0x00, 0x45, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x08, 0x53, 0x56, 0x57, 0x68, 0x00, 0x00, 0x00, 0x00, 0xB8, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x45, 0xFC, 0x00, 0x00,
		0x00, 0x00, 0xFF, 0xD0, 0xBB, 0x00, 0x00, 0x00, 0x00, 0xBF, 0x00, 0x00, 0x00, 0x00, 0xBE, 0x00, 0x00, 0x00, 0x00, 0x85, 0xC0, 0x74, 0x17, 0x68, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xD7, 0x85, 0xC0, 0x74, 0x0C, 0x68, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xD6, 0x83, 0xF8, 0xFF, 0x75, 0x0A, 0xB8, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x50, 0xFF, 0xD3, 0x6A, 0x00, 0x8D, 0x45, 0xF8, 0x50, 0x6A, 0x04,
		0x8D, 0x45, 0xFC, 0x50, 0x68, 0x00, 0x00, 0x00, 0x00, 0xB8, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x85, 0xC0, 0x74, 0x06, 0x83, 0x7D, 0xF8, 0x04, 0x74, 0x0A, 0xB8, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x50, 0xFF, 0xD3, 0x68, 0x00, 0x00, 0x00, 0x00, 0xB8, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x68, 0x00, 0x00, 0x00, 0x00, 0xB8, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x68, 0x00, 0x00, 0x00,
		0x00, 0xFF, 0xD6, 0x83, 0xF8, 0xFF, 0x74, 0x28, 0xBB, 0x00, 0x00, 0x00, 0x00, 0x68, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xD7, 0x85, 0xC0, 0x75, 0x13, 0x68, 0x00, 0x04, 0x00, 0x00, 0xFF, 0xD3, 0x68, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xD6, 0x83, 0xF8, 0xFF, 0x75, 0xE2, 0xBB, 0x00, 0x00, 0x00, 0x00, 0x6A, 0x00, 0xFF, 0xD3, 0x5F, 0x5E, 0x5B, 0x8B, 0xE5, 0x5D, 0xC3, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x06, 0xC5, 0xAF, 0x59, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0xBC, 0x22, 0x00, 0x00, 0xBC, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0xC5, 0xAF, 0x59, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x0C, 0x23, 0x00, 0x00, 0x0C, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0xC5, 0xAF, 0x59,
		0x00, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0xDC, 0x00, 0x00, 0x00, 0x20, 0x23, 0x00, 0x00, 0x20, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0xC5, 0xAF, 0x59, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xA2, 0x22, 0x00, 0x00,
		0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x98, 0x22, 0x00, 0x00, 0x9C, 0x22, 0x00, 0x00, 0xA0, 0x22, 0x00, 0x00, 0x0A, 0x10, 0x00, 0x00, 0xAD, 0x22, 0x00, 0x00, 0x00, 0x00, 0x53, 0x4E, 0x57, 0x55, 0x53, 0x44, 0x2E, 0x64, 0x6C, 0x6C, 0x00, 0x53, 0x65, 0x6C, 0x66, 0x44, 0x65, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x00, 0x00, 0x00, 0x52, 0x53, 0x44, 0x53,
		0xB2, 0x12, 0x04, 0xFE, 0x99, 0x75, 0x40, 0x44, 0x89, 0x0B, 0x41, 0xD5, 0x2C, 0x2E, 0xE5, 0x07, 0x0D, 0x00, 0x00, 0x00, 0x43, 0x3A, 0x5C, 0x55, 0x73, 0x65, 0x72, 0x73, 0x5C, 0x53, 0x61, 0x6E, 0x74, 0x74, 0x75, 0x20, 0x4E, 0x79, 0x6D, 0x61, 0x6E, 0x5C, 0x44, 0x65, 0x73, 0x6B, 0x74, 0x6F, 0x70, 0x5C, 0x53, 0x4E, 0x57, 0x55, 0x53, 0x44, 0x5C, 0x52, 0x65, 0x6C, 0x65, 0x61, 0x73, 0x65,
		0x5C, 0x53, 0x4E, 0x57, 0x55, 0x53, 0x44, 0x2E, 0x70, 0x64, 0x62, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0x43, 0x54, 0x4C, 0x00, 0x10, 0x00, 0x00, 0x6D, 0x08, 0x00, 0x00, 0x2E, 0x74, 0x65, 0x78, 0x74, 0x24, 0x6D, 0x6E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00,
		0x2E, 0x69, 0x64, 0x61, 0x74, 0x61, 0x24, 0x35, 0x00, 0x00, 0x00, 0x00, 0x50, 0x20, 0x00, 0x00, 0x20, 0x02, 0x00, 0x00, 0x2E, 0x72, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0x70, 0x22, 0x00, 0x00, 0x4C, 0x00, 0x00, 0x00, 0x2E, 0x65, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0xBC, 0x22, 0x00, 0x00, 0x40, 0x01, 0x00, 0x00, 0x2E, 0x72, 0x64, 0x61, 0x74, 0x61, 0x24, 0x7A, 0x7A, 0x7A, 0x64, 0x62,
		0x67, 0x00, 0x00, 0x00, 0xFC, 0x23, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x2E, 0x69, 0x64, 0x61, 0x74, 0x61, 0x24, 0x32, 0x00, 0x00, 0x00, 0x00, 0x10, 0x24, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x2E, 0x69, 0x64, 0x61, 0x74, 0x61, 0x24, 0x33, 0x00, 0x00, 0x00, 0x00, 0x24, 0x24, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 0x2E, 0x69, 0x64, 0x61, 0x74, 0x61, 0x24, 0x34, 0x00, 0x00, 0x00, 0x00,
		0x68, 0x24, 0x00, 0x00, 0x3C, 0x01, 0x00, 0x00, 0x2E, 0x69, 0x64, 0x61, 0x74, 0x61, 0x24, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x2E, 0x72, 0x73, 0x72, 0x63, 0x24, 0x30, 0x31, 0x00, 0x00, 0x00, 0x00, 0x60, 0x30, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x2E, 0x72, 0x73, 0x72, 0x63, 0x24, 0x30, 0x32, 0x00, 0x00, 0x00, 0x00, 0x24, 0x24, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x96, 0x25, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x68, 0x24, 0x00, 0x00, 0x7A, 0x24, 0x00, 0x00, 0x88, 0x24, 0x00, 0x00, 0x9C, 0x24, 0x00, 0x00, 0xB2, 0x24, 0x00, 0x00, 0xC2, 0x24, 0x00, 0x00, 0xD8, 0x24, 0x00, 0x00,
		0xF2, 0x24, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x10, 0x25, 0x00, 0x00, 0x26, 0x25, 0x00, 0x00, 0x36, 0x25, 0x00, 0x00, 0x48, 0x25, 0x00, 0x00, 0x56, 0x25, 0x00, 0x00, 0x6C, 0x25, 0x00, 0x00, 0x84, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xBC, 0x05, 0x56, 0x69, 0x72, 0x74, 0x75, 0x61, 0x6C, 0x50, 0x72, 0x6F, 0x74, 0x65, 0x63, 0x74, 0x00, 0x00, 0xB9, 0x05, 0x56, 0x69, 0x72, 0x74,
		0x75, 0x61, 0x6C, 0x46, 0x72, 0x65, 0x65, 0x00, 0x13, 0x02, 0x47, 0x65, 0x74, 0x43, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x50, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x00, 0x70, 0x02, 0x47, 0x65, 0x74, 0x4D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x48, 0x61, 0x6E, 0x64, 0x6C, 0x65, 0x45, 0x78, 0x57, 0x00, 0x00, 0xB6, 0x05, 0x56, 0x69, 0x72, 0x74, 0x75, 0x61, 0x6C, 0x41, 0x6C, 0x6C, 0x6F, 0x63,
		0x00, 0x00, 0x6D, 0x02, 0x47, 0x65, 0x74, 0x4D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x46, 0x69, 0x6C, 0x65, 0x4E, 0x61, 0x6D, 0x65, 0x57, 0x00, 0x00, 0x33, 0x02, 0x47, 0x65, 0x74, 0x45, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x56, 0x61, 0x72, 0x69, 0x61, 0x62, 0x6C, 0x65, 0x57, 0x00, 0xC9, 0x00, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x46, 0x69, 0x6C, 0x65, 0x57, 0x00,
		0x5A, 0x02, 0x47, 0x65, 0x74, 0x4C, 0x61, 0x73, 0x74, 0x45, 0x72, 0x72, 0x6F, 0x72, 0x00, 0x00, 0x7E, 0x02, 0x47, 0x65, 0x74, 0x4E, 0x61, 0x74, 0x69, 0x76, 0x65, 0x53, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x49, 0x6E, 0x66, 0x6F, 0x00, 0xB9, 0x03, 0x4C, 0x6F, 0x61, 0x64, 0x4C, 0x69, 0x62, 0x72, 0x61, 0x72, 0x79, 0x57, 0x00, 0x00, 0xA7, 0x02, 0x47, 0x65, 0x74, 0x50, 0x72, 0x6F, 0x63, 0x41,
		0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x00, 0x00, 0x5A, 0x01, 0x45, 0x78, 0x69, 0x74, 0x50, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x00, 0x14, 0x02, 0x47, 0x65, 0x74, 0x43, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x50, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x49, 0x64, 0x00, 0x9C, 0x01, 0x46, 0x6C, 0x75, 0x73, 0x68, 0x49, 0x6E, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x43, 0x61,
		0x63, 0x68, 0x65, 0x00, 0xCE, 0x05, 0x57, 0x61, 0x69, 0x74, 0x4E, 0x61, 0x6D, 0x65, 0x64, 0x50, 0x69, 0x70, 0x65, 0x57, 0x00, 0x00, 0x4B, 0x45, 0x52, 0x4E, 0x45, 0x4C, 0x33, 0x32, 0x2E, 0x64, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x18, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
		0x09, 0x04, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x60, 0x30, 0x00, 0x00, 0x7D, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x3F, 0x78, 0x6D, 0x6C, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E, 0x3D, 0x27, 0x31, 0x2E, 0x30, 0x27, 0x20, 0x65, 0x6E, 0x63, 0x6F, 0x64, 0x69, 0x6E, 0x67, 0x3D, 0x27, 0x55, 0x54,
		0x46, 0x2D, 0x38, 0x27, 0x20, 0x73, 0x74, 0x61, 0x6E, 0x64, 0x61, 0x6C, 0x6F, 0x6E, 0x65, 0x3D, 0x27, 0x79, 0x65, 0x73, 0x27, 0x3F, 0x3E, 0x0D, 0x0A, 0x3C, 0x61, 0x73, 0x73, 0x65, 0x6D, 0x62, 0x6C, 0x79, 0x20, 0x78, 0x6D, 0x6C, 0x6E, 0x73, 0x3D, 0x27, 0x75, 0x72, 0x6E, 0x3A, 0x73, 0x63, 0x68, 0x65, 0x6D, 0x61, 0x73, 0x2D, 0x6D, 0x69, 0x63, 0x72, 0x6F, 0x73, 0x6F, 0x66, 0x74, 0x2D,
		0x63, 0x6F, 0x6D, 0x3A, 0x61, 0x73, 0x6D, 0x2E, 0x76, 0x31, 0x27, 0x20, 0x6D, 0x61, 0x6E, 0x69, 0x66, 0x65, 0x73, 0x74, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E, 0x3D, 0x27, 0x31, 0x2E, 0x30, 0x27, 0x3E, 0x0D, 0x0A, 0x20, 0x20, 0x3C, 0x74, 0x72, 0x75, 0x73, 0x74, 0x49, 0x6E, 0x66, 0x6F, 0x20, 0x78, 0x6D, 0x6C, 0x6E, 0x73, 0x3D, 0x22, 0x75, 0x72, 0x6E, 0x3A, 0x73, 0x63, 0x68, 0x65,
		0x6D, 0x61, 0x73, 0x2D, 0x6D, 0x69, 0x63, 0x72, 0x6F, 0x73, 0x6F, 0x66, 0x74, 0x2D, 0x63, 0x6F, 0x6D, 0x3A, 0x61, 0x73, 0x6D, 0x2E, 0x76, 0x33, 0x22, 0x3E, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x3C, 0x73, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x3E, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3C, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x65, 0x64, 0x50, 0x72, 0x69, 0x76,
		0x69, 0x6C, 0x65, 0x67, 0x65, 0x73, 0x3E, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3C, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x65, 0x64, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74, 0x69, 0x6F, 0x6E, 0x4C, 0x65, 0x76, 0x65, 0x6C, 0x20, 0x6C, 0x65, 0x76, 0x65, 0x6C, 0x3D, 0x27, 0x61, 0x73, 0x49, 0x6E, 0x76, 0x6F, 0x6B, 0x65, 0x72, 0x27, 0x20, 0x75, 0x69, 0x41, 0x63,
		0x63, 0x65, 0x73, 0x73, 0x3D, 0x27, 0x66, 0x61, 0x6C, 0x73, 0x65, 0x27, 0x20, 0x2F, 0x3E, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3C, 0x2F, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x65, 0x64, 0x50, 0x72, 0x69, 0x76, 0x69, 0x6C, 0x65, 0x67, 0x65, 0x73, 0x3E, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x3C, 0x2F, 0x73, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x3E, 0x0D, 0x0A,
		0x20, 0x20, 0x3C, 0x2F, 0x74, 0x72, 0x75, 0x73, 0x74, 0x49, 0x6E, 0x66, 0x6F, 0x3E, 0x0D, 0x0A, 0x3C, 0x2F, 0x61, 0x73, 0x73, 0x65, 0x6D, 0x62, 0x6C, 0x79, 0x3E, 0x0D, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x10, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x1C, 0x30, 0x2B, 0x30, 0x36, 0x30, 0x3C, 0x30, 0x4B, 0x30, 0x52, 0x30, 0x57, 0x30, 0x60, 0x30, 0x68, 0x30, 0x71, 0x30, 0x79, 0x30, 0x82, 0x30, 0x8D, 0x30, 0x96, 0x30, 0xA1, 0x30, 0xAA, 0x30, 0xB5, 0x30, 0xBE, 0x30, 0xC9, 0x30, 0xD2, 0x30, 0xDD, 0x30, 0xE6, 0x30, 0xF1, 0x30, 0xFA, 0x30, 0x0C, 0x31, 0x14, 0x31, 0x2D, 0x31, 0x33, 0x31,
		0x4F, 0x31, 0x76, 0x31, 0xB1, 0x31, 0xD6, 0x31, 0x10, 0x32, 0x42, 0x32, 0x75, 0x32, 0x7B, 0x32, 0xDB, 0x32, 0x53, 0x33, 0xBC, 0x33, 0x37, 0x34, 0x5D, 0x34, 0x3E, 0x38, 0x4E, 0x38, 0x55, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
#else
	CloseHandle(Pipe);
	HeapFree(Heap, 0, Environment);
	HeapFree(Heap, 0, Command);
	HeapFree(Heap, 0, SystemDirectory);
	HeapFree(Heap, 0, FileName);
	HeapFree(Heap, 0, LibraryFileName);
	return ERROR_DEPENDENCY_NOT_FOUND;
	static const BYTE LibraryFileData[] = { 0 };
#endif
	DWORD Error = snwuStoreFile(LibraryFileName, sizeof(LibraryFileData), (const LPVOID)LibraryFileData);
	if (Error)
	{
		CloseHandle(Pipe);
		HeapFree(Heap, 0, Environment);
		HeapFree(Heap, 0, Command);
		HeapFree(Heap, 0, SystemDirectory);
		HeapFree(Heap, 0, FileName);
		HeapFree(Heap, 0, LibraryFileName);
		return Error;
	}
	STARTUPINFO ProcessStarupInfo;
	PROCESS_INFORMATION ProcessInfo;
	snwuClear(&ProcessStarupInfo, sizeof(STARTUPINFO));
	ProcessStarupInfo.cb = sizeof(STARTUPINFO);
	snwuClear(&ProcessInfo, sizeof(PROCESS_INFORMATION));
	if (!CreateProcessW(0, Command, 0, 0, FALSE, CREATE_DEFAULT_ERROR_MODE | CREATE_UNICODE_ENVIRONMENT | DETACHED_PROCESS, Environment, SystemDirectory, &ProcessStarupInfo, &ProcessInfo))
	{
		DWORD Error = GetLastError();
		DeleteFileW(LibraryFileName);
		CloseHandle(Pipe);
		HeapFree(Heap, 0, Environment);
		HeapFree(Heap, 0, Command);
		HeapFree(Heap, 0, SystemDirectory);
		HeapFree(Heap, 0, FileName);
		HeapFree(Heap, 0, LibraryFileName);
		return Error;
	}
	CloseHandle(ProcessInfo.hThread);
	if (!ConnectNamedPipe(Pipe, 0) && GetLastError() != ERROR_PIPE_CONNECTED)
	{
		DWORD Error = GetLastError();
		TerminateProcess(ProcessInfo.hProcess, (DWORD)-1);
		CloseHandle(ProcessInfo.hProcess);
		DeleteFileW(LibraryFileName);
		CloseHandle(Pipe);
		HeapFree(Heap, 0, Environment);
		HeapFree(Heap, 0, Command);
		HeapFree(Heap, 0, SystemDirectory);
		HeapFree(Heap, 0, FileName);
		HeapFree(Heap, 0, LibraryFileName);
		return Error;
	}
	DWORD PipeDataRead;
	DWORD PipeData;
	SetLastError(0);
	if (!ReadFile(Pipe, &PipeData, sizeof(DWORD), &PipeDataRead, 0) || PipeDataRead != sizeof(DWORD) || PipeData != ProcessInfo.dwProcessId)
	{
		DWORD Error = GetLastError();
		if (!Error)
			Error = ERROR_INTERNAL_ERROR;
		DisconnectNamedPipe(Pipe);
		TerminateProcess(ProcessInfo.hProcess, (UINT)-1);
		CloseHandle(ProcessInfo.hProcess);
		DeleteFileW(LibraryFileName);
		CloseHandle(Pipe);
		HeapFree(Heap, 0, Environment);
		HeapFree(Heap, 0, Command);
		HeapFree(Heap, 0, SystemDirectory);
		HeapFree(Heap, 0, FileName);
		HeapFree(Heap, 0, LibraryFileName);
		return Error;
	}
	CloseHandle(ProcessInfo.hProcess);
	DisconnectNamedPipe(Pipe);
	CloseHandle(Pipe);
	HeapFree(Heap, 0, Environment);
	HeapFree(Heap, 0, Command);
	HeapFree(Heap, 0, SystemDirectory);
	HeapFree(Heap, 0, FileName);
	HeapFree(Heap, 0, LibraryFileName);
	ExitProcess(0);
	return ERROR_INTERNAL_ERROR;
}

DWORD snwuOpenFileInputStream(const WCHAR* FileName, snwuFileInputStream* Stream, SIZE_T BufferSize, ULONGLONG* FileSize)
{
	DWORD Error;
	SIZE_T BufferSizeLimit = 0x10000;
	if (BufferSize > BufferSizeLimit)
	{
		HMODULE Kernel32 = GetModuleHandleW(L"Kernel32.dll");
		if (Kernel32)
		{
			DWORD (WINAPI* GetVersion)(void) = (DWORD (WINAPI*)(void))GetProcAddress(Kernel32, "GetVersion");
			if (GetVersion && LOBYTE(LOWORD(GetVersion())) > 5)
				BufferSizeLimit = 0x80000000;
		}
		if (BufferSize > BufferSizeLimit)
			BufferSize = BufferSizeLimit;
	}
	if (!BufferSize)
		return ERROR_INVALID_PARAMETER;
	HANDLE FileHandle = CreateFileW(FileName, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, FILE_FLAG_OVERLAPPED | FILE_FLAG_SEQUENTIAL_SCAN, 0);
	if (FileHandle == INVALID_HANDLE_VALUE)
		return GetLastError();
	if (!GetFileSizeEx(FileHandle, (LARGE_INTEGER*)FileSize))
	{
		Error = GetLastError();
		CloseHandle(FileHandle);
		return Error;
	}
	if ((ULONGLONG)BufferSize > *FileSize)
		BufferSize = (SIZE_T)*FileSize;
	HANDLE InputEvent = CreateEventW(0, FALSE, FALSE, 0);
	if (!InputEvent)
	{
		Error = GetLastError();
		CloseHandle(FileHandle);
		return Error;
	}
	HANDLE ProcessHeap = GetProcessHeap();
	if (!ProcessHeap)
	{
		Error = GetLastError();
		CloseHandle(InputEvent);
		CloseHandle(FileHandle);
		return Error;
	}
	_snwuInternalFileInputStream* _Stream = (_snwuInternalFileInputStream*)HeapAlloc(ProcessHeap, 0, sizeof(_snwuInternalFileInputStream) + (2 * (_SNWU_INTERNAL_FILE_INPUT_STRAM_BUFFER_ALIGNMENT - 1)) + (2 * BufferSize));
	if (!_Stream)
	{
		Error = GetLastError();
		CloseHandle(InputEvent);
		CloseHandle(FileHandle);
		return Error;
	}
	snwuClear(&_Stream->Overlapped, sizeof(OVERLAPPED));
	_Stream->Overlapped.hEvent = InputEvent;
	_Stream->FileSize = *FileSize;
	_Stream->FilePointer = 0;
	_Stream->FileHandle = FileHandle;
	_Stream->BufferSize = BufferSize;
	_Stream->FrontBuffer = (VOID*)(((UINT_PTR)_Stream + sizeof(_snwuInternalFileInputStream) + (_SNWU_INTERNAL_FILE_INPUT_STRAM_BUFFER_ALIGNMENT - 1)) & ~(_SNWU_INTERNAL_FILE_INPUT_STRAM_BUFFER_ALIGNMENT - 1));
	_Stream->BackBuffer = (VOID*)(((UINT_PTR)_Stream->FrontBuffer + BufferSize + (_SNWU_INTERNAL_FILE_INPUT_STRAM_BUFFER_ALIGNMENT - 1)) & ~(_SNWU_INTERNAL_FILE_INPUT_STRAM_BUFFER_ALIGNMENT - 1));
	_Stream->Status = _SNWU_INTERNAL_FILE_INPUT_STRAM_STATUS_IDLE;
	_Stream->Heap = ProcessHeap;
	*Stream = (snwuFileInputStream)_Stream;
	return 0;
}

DWORD snwuSeekFileInputStream(snwuFileInputStream Stream, ULONGLONG Position)
{
	_snwuInternalFileInputStream* _Stream = (_snwuInternalFileInputStream*)Stream;
	if (_Stream->FileSize < Position)
		return ERROR_INVALID_PARAMETER;
	if (_Stream->Status == _SNWU_INTERNAL_FILE_INPUT_STRAM_STATUS_IDLE)
	{
		_Stream->FilePointer = Position;
		return 0;
	}
	else if (_Stream->Status == _SNWU_INTERNAL_FILE_INPUT_STRAM_STATUS_STREAM)
	{
		CancelIo(_Stream->FileHandle);
		DWORD FileRead;
		DWORD Error = GetOverlappedResult(_Stream->FileHandle, &_Stream->Overlapped, &FileRead, TRUE) ? 0 : GetLastError();
		if (Error && Error != ERROR_OPERATION_ABORTED)
			return Error;
		_Stream->Status = _SNWU_INTERNAL_FILE_INPUT_STRAM_STATUS_IDLE;
		_Stream->FilePointer = Position;
		return 0;
	}
	else
		return ERROR_INVALID_PARAMETER;
}

DWORD snwuReadFileInputStream(snwuFileInputStream Stream, SIZE_T* Size, VOID** Data)
{
	_snwuInternalFileInputStream* _Stream = (_snwuInternalFileInputStream*)Stream;
	if (_Stream->Status == _SNWU_INTERNAL_FILE_INPUT_STRAM_STATUS_STREAM)
	{
		DWORD ReadResult;
		if (!GetOverlappedResult(_Stream->FileHandle, &_Stream->Overlapped, &ReadResult, TRUE))
			return GetLastError();
		_Stream->FilePointer += (ULONGLONG)ReadResult;
		*Size = (SIZE_T)ReadResult;
		LPVOID BackBuffer = _Stream->BackBuffer;
		*Data = BackBuffer;
		_Stream->BackBuffer = _Stream->FrontBuffer;
		_Stream->FrontBuffer = BackBuffer;
		DWORD ReadSize = (DWORD)_Stream->BufferSize;
		if (_Stream->FilePointer + (ULONGLONG)ReadSize > _Stream->FileSize)
			ReadSize = (DWORD)(_Stream->FileSize - _Stream->FilePointer);
		if (!ReadSize)
		{
			_Stream->Status = _SNWU_INTERNAL_FILE_INPUT_STRAM_STATUS_IDLE;
			return 0;
		}
		*(ULONGLONG*)&_Stream->Overlapped.Internal = 0;
		*(ULONGLONG*)&_Stream->Overlapped.Offset = _Stream->FilePointer;
		ReadFile(_Stream->FileHandle, _Stream->BackBuffer, ReadSize, 0, &_Stream->Overlapped);
		DWORD ReadFileError = GetLastError();
		if (ReadFileError && ReadFileError != ERROR_IO_PENDING)
		{
			_Stream->Status = _SNWU_INTERNAL_FILE_INPUT_STRAM_STATUS_IDLE;
			return 0;
		}
		return 0;
	}
	else if (_Stream->Status == _SNWU_INTERNAL_FILE_INPUT_STRAM_STATUS_IDLE)
	{
		DWORD ReadSize = (DWORD)_Stream->BufferSize;
		if (_Stream->FilePointer + (ULONGLONG)ReadSize > _Stream->FileSize)
			ReadSize = (DWORD)(_Stream->FileSize - _Stream->FilePointer);
		if (!ReadSize)
			return ERROR_HANDLE_EOF;
		*(ULONGLONG*)&_Stream->Overlapped.Internal = 0;
		*(ULONGLONG*)&_Stream->Overlapped.Offset = _Stream->FilePointer;
		ReadFile(_Stream->FileHandle, _Stream->BackBuffer, ReadSize, 0, &_Stream->Overlapped);
		DWORD ReadFileError = GetLastError();
		if (ReadFileError && ReadFileError != ERROR_IO_PENDING)
			return ReadFileError;
		_Stream->Status = _SNWU_INTERNAL_FILE_INPUT_STRAM_STATUS_STREAM;
		*Size = 0;
		*Data = 0;
		return 0;
	}
	else
		return ERROR_INVALID_PARAMETER;
}

void snwuCloseFileInputStream(snwuFileInputStream Stream)
{
	_snwuInternalFileInputStream* _Stream = (_snwuInternalFileInputStream*)Stream;
	if (_Stream->Status == _SNWU_INTERNAL_FILE_INPUT_STRAM_STATUS_STREAM)
	{
		CancelIo(_Stream->FileHandle);
		DWORD FileRead;
		GetOverlappedResult(_Stream->FileHandle, &_Stream->Overlapped, &FileRead, TRUE);
	}
	CloseHandle(_Stream->FileHandle);
	CloseHandle(_Stream->Overlapped.hEvent);
	HeapFree(_Stream->Heap, 0, _Stream);
}

#ifdef __cplusplus
}
#endif

#endif